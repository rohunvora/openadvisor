Directory structure:
└── rohunvora-traderfm/
    ├── README.md
    ├── docker-compose.yml
    ├── Dockerfile
    ├── Dockerfile.railway
    ├── LICENSE
    ├── nixpacks.toml
    ├── package.json
    ├── railway.json
    ├── RAILWAY_DEPLOY.md
    ├── render.yaml
    ├── setup.sh
    ├── vercel.json
    ├── VERCEL_SPLIT_DEPLOY.md
    ├── backend/
    │   ├── env.example
    │   ├── package.json
    │   └── src/
    │       ├── index.js
    │       ├── middleware/
    │       │   ├── auth.js
    │       │   └── validation.js
    │       ├── routes/
    │       │   ├── answers.js
    │       │   ├── questions.js
    │       │   ├── stats.js
    │       │   ├── telegram.js
    │       │   ├── twitter-auth.js
    │       │   └── users.js
    │       └── utils/
    │           ├── database.js
    │           ├── initDb.js
    │           ├── migrations.js
    │           └── telegram.js
    └── frontend/
        ├── index.html
        ├── package.json
        ├── postcss.config.js
        ├── tailwind.config.js
        ├── vite.config.js
        └── src/
            ├── App.jsx
            ├── index.css
            ├── main.jsx
            ├── components/
            │   ├── ErrorBoundary.jsx
            │   ├── Layout.jsx
            │   └── Loading.jsx
            ├── hooks/
            │   ├── useActivity.jsx
            │   └── useAuth.jsx
            ├── pages/
            │   ├── HomePage.jsx
            │   ├── InboxPage.jsx
            │   └── ProfilePage.jsx
            ├── services/
            │   └── api.js
            └── utils/
                ├── profanity.js
                └── validation.js

================================================
FILE: README.md
================================================
# TraderFM - Anonymous Q&A Platform for Traders

TraderFM is a modern anonymous Q&A platform designed specifically for traders. Users can create handles, receive anonymous questions about trading, markets, and investment strategies, and share their insights publicly.

## Features

- 🎭 **100% Anonymous Questions** - No signup required to ask questions
- 🔐 **Secure Handle System** - Create a handle with a secret key for authentication
- 💬 **Real-time Updates** - Questions and answers update automatically
- 🛡️ **Profanity Filter** - Built-in content moderation
- ⚡ **Rate Limiting** - Prevents spam and abuse
- 📱 **Responsive Design** - Works great on mobile and desktop
- 🚀 **Fast & Lightweight** - Built with React and SQLite

## Tech Stack

**Frontend:**
- React 18 with Vite
- React Router for navigation
- TanStack Query for data fetching
- Tailwind CSS for styling
- Axios for API calls

**Backend:**
- Node.js with Express
- SQLite database with better-sqlite3
- JWT authentication
- Express Rate Limit
- Helmet for security

## Quick Start

### Prerequisites

- Node.js 16+ and npm
- Git

### Local Development

1. **Clone the repository:**
```bash
git clone https://github.com/rohunvora/traderfm.git
cd traderfm
```

2. **Install dependencies:**
```bash
# Install backend dependencies
cd backend
npm install

# Install frontend dependencies
cd ../frontend
npm install
```

3. **Set up environment variables:**
```bash
# In the backend directory
cp env.example .env
# Edit .env with your settings
```

4. **Start the development servers:**

In separate terminals:

```bash
# Terminal 1 - Backend
cd backend
npm run dev

# Terminal 2 - Frontend
cd frontend
npm run dev
```

5. **Access the application:**
- Frontend: http://localhost:3000
- Backend API: http://localhost:5000

### Docker Development

For a containerized development environment:

```bash
# Start all services
docker-compose --profile dev up

# Or just the production build
docker-compose up
```

## Production Deployment

### Using Docker

1. **Build and run with Docker Compose:**
```bash
docker-compose up -d
```

2. **Or build the Docker image manually:**
```bash
docker build -t traderfm .
docker run -p 5000:5000 -v $(pwd)/data:/app/backend/data traderfm
```

### Manual Deployment

1. **Build the frontend:**
```bash
cd frontend
npm run build
```

2. **Set up production environment:**
```bash
cd backend
npm install --production
export NODE_ENV=production
export JWT_SECRET=your-secret-key-here
```

3. **Start the server:**
```bash
node src/index.js
```

### Deploy to Cloud Platforms

**Heroku:**
```bash
heroku create your-app-name
heroku config:set JWT_SECRET=your-secret-key
git push heroku main
```

**Railway:**
1. Connect your GitHub repo to Railway
2. Set environment variables in Railway dashboard
3. Deploy!

**DigitalOcean App Platform:**
1. Create a new app from GitHub
2. Configure environment variables
3. Set build command: `cd frontend && npm install && npm run build`
4. Set run command: `cd backend && npm install && node src/index.js`

## API Documentation

### Public Endpoints

**Check if handle exists:**
```
GET /api/users/check/:handle
```

**Create new handle:**
```
POST /api/users/create
Body: { "handle": "yourhandle" }
```

**Ask a question:**
```
POST /api/questions/:handle
Body: { "text": "Your question here" }
```

**Get answers:**
```
GET /api/answers/:handle?page=1&limit=20
```

### Authenticated Endpoints

**Login:**
```
POST /api/users/auth
Body: { "handle": "yourhandle", "secretKey": "your-secret" }
```

**Get unanswered questions:**
```
GET /api/questions/:handle/unanswered
Headers: { "Authorization": "Bearer YOUR_TOKEN" }
```

**Answer a question:**
```
POST /api/questions/:id/answer
Headers: { "Authorization": "Bearer YOUR_TOKEN" }
Body: { "answerText": "Your answer" }
```

## Project Structure

```
traderfm/
├── frontend/               # React frontend
│   ├── src/
│   │   ├── components/    # Reusable components
│   │   ├── pages/        # Page components
│   │   ├── services/     # API services
│   │   ├── hooks/        # Custom React hooks
│   │   └── utils/        # Utility functions
│   └── package.json
├── backend/               # Express backend
│   ├── src/
│   │   ├── routes/       # API routes
│   │   ├── middleware/   # Express middleware
│   │   ├── utils/        # Utility functions
│   │   └── index.js      # Main server file
│   └── package.json
├── docker-compose.yml     # Docker configuration
└── Dockerfile            # Container definition
```

## Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `PORT` | Server port | 5000 |
| `NODE_ENV` | Environment (development/production) | development |
| `JWT_SECRET` | Secret key for JWT tokens | (required) |
| `FRONTEND_URL` | Frontend URL for CORS | http://localhost:3000 |

## Contributing

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/amazing-feature`
3. Commit your changes: `git commit -m 'Add amazing feature'`
4. Push to the branch: `git push origin feature/amazing-feature`
5. Open a Pull Request

## Security Considerations

- Change the default JWT_SECRET in production
- Use HTTPS in production
- Keep dependencies updated
- Enable CORS only for your frontend domain
- Consider adding rate limiting to all endpoints
- Implement input sanitization
- Use environment variables for sensitive data

## License

This project is open source and available under the [MIT License](LICENSE).

## Support

For issues, questions, or contributions, please visit the [GitHub repository](https://github.com/rohunvora/traderfm).



================================================
FILE: docker-compose.yml
================================================
version: '3.8'

services:
  backend:
    build: 
      context: .
      dockerfile: Dockerfile
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=production
      - JWT_SECRET=change-this-secret-key-in-production
      - PORT=5000
    volumes:
      - ./backend/data:/app/backend/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:5000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Development services
  frontend-dev:
    image: node:18-alpine
    working_dir: /app
    command: npm run dev
    ports:
      - "3000:3000"
    volumes:
      - ./frontend:/app
    environment:
      - NODE_ENV=development
    profiles:
      - dev

  backend-dev:
    image: node:18-alpine
    working_dir: /app
    command: npm run dev
    ports:
      - "5001:5000"
    volumes:
      - ./backend:/app
    environment:
      - NODE_ENV=development
      - JWT_SECRET=dev-secret-key
      - PORT=5000
    profiles:
      - dev 


================================================
FILE: Dockerfile
================================================
# Build stage for frontend
FROM node:18-alpine AS frontend-build
WORKDIR /app/frontend
COPY frontend/package*.json ./
RUN npm install
COPY frontend/ ./
RUN npm run build

# Build stage for backend
FROM node:18-alpine AS backend-build
WORKDIR /app/backend
COPY backend/package*.json ./
RUN npm install --only=production

# Final stage
FROM node:18-alpine
WORKDIR /app

# Install dumb-init for proper signal handling
RUN apk add --no-cache dumb-init

# Copy backend
COPY --from=backend-build /app/backend/node_modules ./backend/node_modules
COPY backend/ ./backend/

# Copy frontend build
COPY --from=frontend-build /app/frontend/dist ./frontend/dist

# Create data directory
RUN mkdir -p ./backend/data

# Set environment variables
ENV NODE_ENV=production
ENV PORT=5000

# Expose port
EXPOSE 5000

# Use non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001
RUN chown -R nodejs:nodejs /app
USER nodejs

# Start the application
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "backend/src/index.js"] 


================================================
FILE: Dockerfile.railway
================================================
# Railway Dockerfile for TraderFM
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY frontend/package*.json ./frontend/
COPY backend/package*.json ./backend/

# Install dependencies
RUN npm install --only=production
RUN cd frontend && npm install
RUN cd backend && npm install --only=production

# Copy source code
COPY frontend/ ./frontend/
COPY backend/ ./backend/

# Build frontend
RUN cd frontend && npm run build

# Create data directory for SQLite with proper permissions
RUN mkdir -p backend/data && \
    chmod 777 backend/data

# Set environment
ENV NODE_ENV=production

# Expose port (Railway will set this automatically)
EXPOSE 5001

# Start the backend server
CMD ["node", "backend/src/index.js"] 


================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2024 TraderFM

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. 


================================================
FILE: nixpacks.toml
================================================
[variables]
NODE_VERSION = "18"

[phases.setup]
nixPkgs = ["nodejs", "npm"]

[phases.install]
cmds = [
  "npm install",
  "cd frontend && npm install",
  "cd backend && npm install --only=production"
]

[phases.build]
cmds = [
  "cd frontend && npm run build"
]

[start]
cmd = "cd backend && node src/index.js" 


================================================
FILE: package.json
================================================
{
  "name": "traderfm",
  "version": "1.0.0",
  "description": "Anonymous Q&A platform for traders",
  "private": true,
  "scripts": {
    "install:all": "npm install && cd frontend && npm install && cd ../backend && npm install",
    "dev": "concurrently \"npm run dev:backend\" \"npm run dev:frontend\"",
    "dev:frontend": "cd frontend && npm run dev",
    "dev:backend": "cd backend && npm run dev",
    "build": "cd frontend && npm install && npm run build && cd ../backend && npm install",
    "start": "cd backend && npm start",
    "docker:build": "docker-compose build",
    "docker:up": "docker-compose up",
    "docker:dev": "docker-compose --profile dev up",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rohunvora/traderfm.git"
  },
  "keywords": [
    "traders",
    "q&a",
    "anonymous",
    "social"
  ],
  "author": "",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/rohunvora/traderfm/issues"
  },
  "homepage": "https://github.com/rohunvora/traderfm#readme",
  "devDependencies": {
    "concurrently": "^8.2.2"
  },
  "engines": {
    "node": ">=16.0.0",
    "npm": ">=7.0.0"
  }
}



================================================
FILE: railway.json
================================================
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "DOCKERFILE",
    "dockerfilePath": "Dockerfile.railway"
  },
  "deploy": {
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
} 


================================================
FILE: RAILWAY_DEPLOY.md
================================================
# Deploy to Railway

## Quick Deploy

1. **Push your code to GitHub**
2. **Go to [railway.app](https://railway.app) and login**
3. **Create new project → Deploy from GitHub**
4. **Select your repository**

Railway will automatically use the `Dockerfile.railway` for deployment.

## Environment Variables to Set

In Railway dashboard, set these environment variables:

### Required:
- `JWT_SECRET`: A secure random string (generate with `openssl rand -base64 32`)
- `NODE_ENV`: `production`

### For Twitter OAuth (Optional but Recommended):
- `TWITTER_API_KEY`: Your Twitter API key (Consumer Key) from developer.twitter.com
- `TWITTER_API_SECRET`: Your Twitter API secret (Consumer Secret) from developer.twitter.com
- `BASE_URL`: Your Railway backend URL (e.g., https://your-app.up.railway.app)
- `TWITTER_CALLBACK_URL`: Your Twitter callback URL (e.g., https://your-app.up.railway.app/api/auth/twitter/callback)

### Optional:
- `PORT`: Railway sets this automatically, but you can override if needed

## Alternative Deployment Methods

### Method 1: Dockerfile (Recommended - Currently Active)
Uses `Dockerfile.railway` and `railway.json` with Dockerfile builder.

### Method 2: Nixpacks
If you prefer Nixpacks, update `railway.json`:
```json
{
  "build": {
    "builder": "NIXPACKS"
  }
}
```
This will use the `nixpacks.toml` configuration.

## What Railway Will Do

1. Build using Docker (or Nixpacks)
2. Install frontend and backend dependencies
3. Build frontend static files
4. Start backend server (which serves both API and frontend)
5. Provide persistent storage for SQLite database

## After Deployment

1. Railway will give you a URL like `https://yourapp.railway.app`
2. Your app will be fully functional with:
   - Frontend at the root URL
   - API at `/api/*` endpoints
   - Persistent SQLite database
   - JWT authentication working

## Common Issues

- **Port Error**: Railway automatically sets PORT environment variable
- **Build Error**: Check deployment logs for specific npm/build errors
- **Database Path**: SQLite file is stored in `/app/backend/data/`

## Database

- SQLite database persists in `/app/backend/data/`
- Data survives deployments and restarts
- No additional database setup needed

## Troubleshooting

If deployment fails:
1. Check Railway logs for specific errors
2. Try switching between Dockerfile and Nixpacks methods
3. Ensure all package.json files are committed
4. Verify environment variables are set correctly 


================================================
FILE: render.yaml
================================================
services:
  - type: web
    name: traderfm
    runtime: node
    buildCommand: cd frontend && npm install && npm run build && cd ../backend && npm install
    startCommand: cd backend && npm start
    envVars:
      - key: NODE_ENV
        value: production
      - key: JWT_SECRET
        generateValue: true
      - key: PORT
        value: 5000
    disk:
      name: data
      mountPath: /opt/render/project/src/backend/data
      sizeGB: 1 


================================================
FILE: setup.sh
================================================
#!/bin/bash

echo "🚀 Setting up TraderFM..."

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Check if Node.js is installed
if ! command -v node &> /dev/null; then
    echo "❌ Node.js is not installed. Please install Node.js 16+ first."
    exit 1
fi

echo "✅ Node.js $(node -v) detected"

# Install root dependencies
echo -e "\n${YELLOW}Installing root dependencies...${NC}"
npm install

# Install frontend dependencies
echo -e "\n${YELLOW}Installing frontend dependencies...${NC}"
cd frontend
npm install
cd ..

# Install backend dependencies
echo -e "\n${YELLOW}Installing backend dependencies...${NC}"
cd backend
npm install

# Create .env file if it doesn't exist
if [ ! -f .env ]; then
    echo -e "\n${YELLOW}Creating .env file...${NC}"
    cp env.example .env
    echo -e "${GREEN}✅ .env file created. Please update it with your settings.${NC}"
else
    echo -e "\n${GREEN}✅ .env file already exists${NC}"
fi

# Initialize database
echo -e "\n${YELLOW}Initializing database...${NC}"
npm run db:init

cd ..

echo -e "\n${GREEN}✅ Setup complete!${NC}"
echo -e "\nTo start development servers:"
echo -e "  ${YELLOW}npm run dev${NC}"
echo -e "\nOr start them separately:"
echo -e "  Backend: ${YELLOW}cd backend && npm run dev${NC}"
echo -e "  Frontend: ${YELLOW}cd frontend && npm run dev${NC}" 


================================================
FILE: vercel.json
================================================
{
  "buildCommand": "cd frontend && npm install && npm run build",
  "outputDirectory": "frontend/dist",
  "installCommand": "npm install",
  "framework": null,
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/index.html"
    }
  ],
  "env": {
    "VITE_API_URL": "https://your-backend-url.railway.app/api"
  }
} 


================================================
FILE: VERCEL_SPLIT_DEPLOY.md
================================================
# Split Deployment: Vercel + Railway

Since you've already deployed to Vercel, here's how to make it work with a split frontend/backend deployment.

## Step 1: Deploy Backend to Railway

1. **Go to [railway.app](https://railway.app)**
2. **Create new project → Deploy from GitHub**
3. **Select your repository**
4. **Set environment variables:**
   ```
   JWT_SECRET=your-secure-random-string
   NODE_ENV=production
   ```
5. **Note the Railway URL** (e.g., `https://yourapp.railway.app`)

## Step 2: Configure Vercel Frontend

1. **In your Vercel dashboard, go to your project settings**
2. **Add environment variable:**
   ```
   VITE_API_URL = https://your-railway-app.railway.app/api
   ```
   *(Replace with your actual Railway URL)*

3. **Redeploy your Vercel frontend**

## Step 3: Update CORS on Backend

The backend needs to allow requests from your Vercel domain.

Update your environment variable on Railway:
```
FRONTEND_URL=https://your-vercel-app.vercel.app
```

## Alternative: Use Railway for Everything (Simpler)

Instead of split deployment, you can use Railway for both frontend and backend:

1. **Delete the Vercel deployment**
2. **Deploy everything to Railway** (it's already configured)
3. **Set environment variables on Railway:**
   ```
   JWT_SECRET=your-secure-random-string
   NODE_ENV=production
   ```

This is simpler because:
- ✅ One deployment to manage
- ✅ No CORS issues
- ✅ Built-in database persistence
- ✅ Automatic HTTPS

## Current Issue

Your Vercel deployment is trying to call `/api/users/create` but Vercel can't handle the Express backend routes. You need either:

1. **Backend deployed separately** (Railway/Render/Heroku)
2. **Full-stack deployment** (Railway with both frontend and backend)

Choose the approach that works best for you! 


================================================
FILE: backend/env.example
================================================
# Backend configuration
PORT=5001
NODE_ENV=development

# JWT Secret - REQUIRED! Generate a secure random string for production
# On Railway: Set this in the environment variables
JWT_SECRET=your-super-secret-key-change-in-production

# Frontend URL for CORS
# On Railway: Set this to your deployed frontend URL
FRONTEND_URL=http://localhost:3000

# Base URL for callback generation
# On Railway: Set this to your deployed backend URL
BASE_URL=http://localhost:5001

# Twitter OAuth - Get these from developer.twitter.com
# IMPORTANT: Use Consumer Key and Consumer Secret from your Twitter app
# Note: Twitter uses OAuth 1.0a
TWITTER_API_KEY=your-twitter-consumer-key
TWITTER_API_SECRET=your-twitter-consumer-secret
TWITTER_CALLBACK_URL=http://localhost:5001/api/auth/twitter/callback

# Telegram Bot Configuration (Optional - for notifications)
# Create a bot via @BotFather on Telegram
TELEGRAM_BOT_TOKEN=your-telegram-bot-token
TELEGRAM_BOT_USERNAME=your_bot_username

# Database path (SQLite)
# Railway will automatically provide persistent storage
# DB_PATH=./data/traderfm.db 


================================================
FILE: backend/package.json
================================================
{
  "name": "traderfm-backend",
  "version": "1.0.0",
  "description": "Backend API for TraderFM",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "db:init": "node src/utils/initDb.js"
  },
  "dependencies": {
    "axios": "^1.9.0",
    "bad-words": "^3.0.4",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^7.1.1",
    "express-session": "^1.18.1",
    "express-validator": "^7.0.1",
    "helmet": "^7.0.0",
    "jsonwebtoken": "^9.0.2",
    "passport": "^0.7.0",
    "passport-twitter": "^1.0.4",
    "sqlite3": "^5.1.6",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  },
  "engines": {
    "node": ">=14.0.0"
  }
}



================================================
FILE: backend/src/index.js
================================================
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const session = require('express-session');
const passport = require('passport');
const path = require('path');
require('dotenv').config();

// Validate required environment variables
if (!process.env.JWT_SECRET) {
  console.error('❌ FATAL: JWT_SECRET environment variable is required');
  process.exit(1);
}

// Import routes
const userRoutes = require('./routes/users');
const questionRoutes = require('./routes/questions');
const answerRoutes = require('./routes/answers');
const statsRoutes = require('./routes/stats');
const twitterAuthRoutes = require('./routes/twitter-auth');
const telegramRoutes = require('./routes/telegram');

// Import database
const db = require('./utils/database');
const { statements } = require('./utils/database');

const app = express();
const PORT = process.env.PORT || 5001;

// Trust proxy for Railway deployment (specific configuration)
if (process.env.NODE_ENV === 'production') {
  // Railway uses specific proxy headers
  app.set('trust proxy', 1); // Trust first proxy
}

// Store recent logs in memory for debugging
const recentLogs = [];
const maxLogs = 50;

// Custom logger that stores logs
const logger = {
  log: (message) => {
    const timestamp = new Date().toISOString();
    const logEntry = `${timestamp} ${message}`;
    console.log(logEntry);
    recentLogs.push(logEntry);
    if (recentLogs.length > maxLogs) {
      recentLogs.shift(); // Remove oldest log
    }
  },
  error: (message, error) => {
    const timestamp = new Date().toISOString();
    const logEntry = `${timestamp} ERROR: ${message} ${error ? error.toString() : ''}`;
    console.error(logEntry);
    recentLogs.push(logEntry);
    if (recentLogs.length > maxLogs) {
      recentLogs.shift();
    }
  }
};

// Make logger available globally
global.logger = logger;

console.log('🚀 Starting TraderFM server...');
console.log('📦 Environment:', process.env.NODE_ENV);
console.log('🔑 JWT_SECRET:', process.env.JWT_SECRET ? 'Set ✅' : 'Missing ❌');
console.log('🐦 Twitter API Key:', process.env.TWITTER_API_KEY ? 'Set ✅' : 'Missing ❌');
console.log('🐦 Twitter API Secret:', process.env.TWITTER_API_SECRET ? 'Set ✅' : 'Missing ❌');
console.log('🔗 Base URL:', process.env.BASE_URL || 'Not set (using defaults)');
console.log('🔗 Twitter Callback URL:', process.env.TWITTER_CALLBACK_URL || 'Not set (using defaults)');
console.log('🤖 Telegram Bot Token:', process.env.TELEGRAM_BOT_TOKEN ? 'Set ✅' : 'Not set (notifications disabled)');
console.log('🤖 Telegram Bot Username:', process.env.TELEGRAM_BOT_USERNAME || 'Not set');

// Security middleware with updated CSP for Twitter images
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
      imgSrc: ["'self'", "data:", "https://pbs.twimg.com", "https://abs.twimg.com"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
}));
app.use(cors({
  origin: process.env.FRONTEND_URL || true,
  credentials: true
}));

// Body parsing middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Session middleware - required for Twitter OAuth 1.0a
// Using memory store with short TTL since sessions are only used during OAuth flow
const sessionConfig = {
  secret: process.env.JWT_SECRET || 'your-secret-key',
  resave: false,
  saveUninitialized: true, // Need to save uninitialized sessions for OAuth
  name: 'traderfm.sid', // Custom session name
  cookie: { 
    secure: false, // Railway handles HTTPS, we receive HTTP internally
    httpOnly: true,
    sameSite: 'lax', // Important for OAuth redirects
    maxAge: 10 * 60 * 1000 // 10 minutes - only needed during OAuth flow
  }
};

// Additional proxy configuration for sessions
if (process.env.NODE_ENV === 'production') {
  sessionConfig.proxy = true; // Trust the proxy for secure cookies
}

app.use(session(sessionConfig));

// Passport middleware
app.use(passport.initialize());
app.use(passport.session());

// Global rate limiting
const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 1000, // increased from 100 to 1000 requests per windowMs
  message: 'Too many requests from this IP',
  standardHeaders: true, // Return rate limit info in the headers
  legacyHeaders: false, // Disable the X-RateLimit-* headers
  // Skip successful requests from rate limiting
  skipSuccessfulRequests: false,
  // Use default key generator (req.ip) which respects trust proxy
  keyGenerator: (req) => req.ip,
  // Skip certain endpoints from rate limiting
  skip: (req) => {
    // Don't rate limit health checks, directory, or public profile views
    return req.path === '/api/health' || 
           req.path === '/api/users/directory' ||
           req.path.startsWith('/api/users/check/') ||
           req.path.startsWith('/api/answers/');
  }
});
app.use('/api/', globalLimiter);

// Question-specific rate limiting
const questionLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 5, // increased from 3 to 5 questions per minute
  message: 'Too many questions. Please wait before asking again.',
  standardHeaders: true,
  legacyHeaders: false,
  skipSuccessfulRequests: false,
  keyGenerator: (req) => {
    // Use IP + handle to rate limit per handle
    return `${req.ip}-${req.params.handle}`;
  }
});

// Auth-specific rate limiting for Twitter auth
const authLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 10, // 10 auth attempts per 5 minutes
  message: 'Too many authentication attempts. Please wait before trying again.',
  standardHeaders: true,
  legacyHeaders: false,
  skipSuccessfulRequests: false,
  keyGenerator: (req) => req.ip
});

// API Routes
app.use('/api/users', userRoutes);
app.use('/api/questions', questionRoutes);
app.use('/api/answers', answerRoutes);
app.use('/api/stats', statsRoutes);
app.use('/api/telegram', telegramRoutes);

// Activity endpoint for real-time updates
app.get('/api/activity', async (req, res) => {
  try {
    const since = req.query.since ? new Date(req.query.since) : new Date(Date.now() - 30000); // Last 30 seconds by default
    
    // Get recent questions, answers, and new users
    const [recentQuestions, recentAnswers, recentUsers] = await Promise.all([
      statements.getRecentQuestions.all(since.toISOString()),
      statements.getRecentAnswers.all(since.toISOString()),
      statements.getRecentUsers.all(since.toISOString())
    ]);
    
    res.json({
      timestamp: new Date().toISOString(),
      questions: recentQuestions || [],
      answers: recentAnswers || [],
      users: recentUsers || []
    });
  } catch (error) {
    console.error('Activity endpoint error:', error);
    res.json({ 
      timestamp: new Date().toISOString(),
      questions: [], 
      answers: [], 
      users: [] 
    });
  }
});

// Apply auth-specific rate limiter to Twitter auth routes
app.use('/api/auth', authLimiter, twitterAuthRoutes);

// Apply question rate limiter to ask question endpoint specifically
app.post('/api/questions/:handle', questionLimiter);

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV,
    port: PORT
  });
});

// Logs endpoint to view recent application logs
app.get('/api/logs', (req, res) => {
  res.json({
    timestamp: new Date().toISOString(),
    totalLogs: recentLogs.length,
    logs: recentLogs.slice(-20) // Show last 20 logs
  });
});

// Rate limit info endpoint (for debugging)
app.get('/api/rate-limit-info', (req, res) => {
  res.json({
    ip: req.ip,
    headers: {
      'x-forwarded-for': req.headers['x-forwarded-for'],
      'x-real-ip': req.headers['x-real-ip'],
      'x-forwarded-host': req.headers['x-forwarded-host']
    },
    message: 'Check the response headers for rate limit information'
  });
});

// Debug endpoint to check database status
app.get('/api/debug', async (req, res) => {
  try {
    const fs = require('fs');
    const path = require('path');
    
    const dataDir = path.join(__dirname, '../data');
    const dbPath = path.join(dataDir, 'traderfm.db');
    
    const debugInfo = {
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV,
      jwtSecret: process.env.JWT_SECRET ? 'SET' : 'MISSING',
      dataDir: {
        path: dataDir,
        exists: fs.existsSync(dataDir),
        readable: fs.existsSync(dataDir) ? fs.constants.R_OK : false,
        writable: fs.existsSync(dataDir) ? fs.constants.W_OK : false
      },
      database: {
        path: dbPath,
        exists: fs.existsSync(dbPath),
        size: fs.existsSync(dbPath) ? fs.statSync(dbPath).size : 0
      },
      workingDirectory: process.cwd(),
      platform: process.platform,
      nodeVersion: process.version
    };
    
    res.json(debugInfo);
  } catch (error) {
    res.status(500).json({
      error: 'Debug endpoint failed',
      message: error.message,
      stack: error.stack
    });
  }
});

// Serve static files in production
if (process.env.NODE_ENV === 'production') {
  app.use(express.static(path.join(__dirname, '../../frontend/dist')));
  
  app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, '../../frontend/dist/index.html'));
  });
}

// Error handling middleware
app.use((err, req, res, next) => {
  console.error('❌ Server Error:', err.stack);
  
  if (err.type === 'entity.too.large') {
    return res.status(413).json({ message: 'Request too large' });
  }
  
  res.status(err.status || 500).json({
    message: err.message || 'Internal server error',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});

// 404 handler
app.use((req, res) => {
  console.log('❓ 404 Request:', req.method, req.url);
  res.status(404).json({ message: 'Route not found' });
});

// Initialize database
db.init().then(() => {
  console.log('✅ Database initialized');
  
  // Start server
  app.listen(PORT, () => {
    console.log(`🌟 Server running on port ${PORT}`);
    console.log(`📍 Environment: ${process.env.NODE_ENV || 'development'}`);
    console.log(`🔗 Health check: http://localhost:${PORT}/api/health`);
  });
}).catch(err => {
  console.error('❌ Failed to initialize database:', err);
  process.exit(1);
}); 


================================================
FILE: backend/src/middleware/auth.js
================================================
const jwt = require('jsonwebtoken');
const { statements } = require('../utils/database');

const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-key-change-in-production';

// Generate JWT token
const generateToken = (userId, handle) => {
  return jwt.sign(
    { userId, handle },
    JWT_SECRET,
    { expiresIn: '30d' }
  );
};

// Verify JWT token middleware
const authenticate = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ message: 'No token provided' });
    }
    
    const token = authHeader.substring(7);
    
    try {
      const decoded = jwt.verify(token, JWT_SECRET);
      
      // Get user from database
      const user = await statements.getUserById.get(decoded.userId);
      
      if (!user) {
        return res.status(401).json({ message: 'User not found' });
      }
      
      // Attach user to request
      req.user = {
        id: user.id,
        handle: user.handle
      };
      
      next();
    } catch (jwtError) {
      return res.status(401).json({ message: 'Invalid token' });
    }
  } catch (error) {
    console.error('Auth middleware error:', error);
    res.status(500).json({ message: 'Authentication error' });
  }
};

// Optional authentication - doesn't fail if no token
const optionalAuth = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (authHeader && authHeader.startsWith('Bearer ')) {
      const token = authHeader.substring(7);
      
      try {
        const decoded = jwt.verify(token, JWT_SECRET);
        const user = await statements.getUserById.get(decoded.userId);
        
        if (user) {
          req.user = {
            id: user.id,
            handle: user.handle
          };
        }
      } catch (jwtError) {
        // Ignore invalid tokens for optional auth
      }
    }
    
    next();
  } catch (error) {
    console.error('Optional auth error:', error);
    next();
  }
};

module.exports = {
  generateToken,
  authenticate,
  optionalAuth
}; 


================================================
FILE: backend/src/middleware/validation.js
================================================
const { body, param, validationResult } = require('express-validator');
const Filter = require('bad-words');

const filter = new Filter();

// Custom validation middleware
const validate = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ 
      message: 'Validation failed',
      errors: errors.array() 
    });
  }
  next();
};

// Handle validation rules
const handleRules = [
  body('handle')
    .trim()
    .isLength({ min: 3, max: 20 })
    .withMessage('Handle must be between 3 and 20 characters')
    .matches(/^[a-z0-9]+$/)
    .withMessage('Handle can only contain lowercase letters and numbers')
    .custom((value) => {
      if (/^\d+$/.test(value)) {
        throw new Error('Handle cannot be only numbers');
      }
      return true;
    })
    .custom((value) => {
      const reserved = ['api', 'admin', 'inbox', 'login', 'signup', 'about', 'help', 'support'];
      if (reserved.includes(value.toLowerCase())) {
        throw new Error('This handle is reserved');
      }
      return true;
    })
];

// Question validation rules
const questionRules = [
  body('text')
    .trim()
    .isLength({ min: 5, max: 280 })
    .withMessage('Question must be between 5 and 280 characters')
    .custom((value) => {
      // Check if it's just repeated characters
      if (/^(.)\1+$/.test(value)) {
        throw new Error('Please ask a real question');
      }
      return true;
    })
    .custom((value) => {
      // Check if it contains actual text
      if (!/[a-zA-Z0-9]/.test(value)) {
        throw new Error('Question must contain some text');
      }
      return true;
    })
    .custom((value) => {
      // Check for profanity
      if (filter.isProfane(value)) {
        throw new Error('Please keep your question respectful');
      }
      return true;
    })
];

// Answer validation rules
const answerRules = [
  body('answerText')
    .trim()
    .isLength({ min: 1, max: 1000 })
    .withMessage('Answer must be between 1 and 1000 characters')
];

// Auth validation rules
const authRules = [
  body('handle')
    .trim()
    .notEmpty()
    .withMessage('Handle is required'),
  body('secretKey')
    .trim()
    .notEmpty()
    .withMessage('Secret key is required')
];

// Parameter validation
const handleParamRules = [
  param('handle')
    .matches(/^[a-z0-9]+$/)
    .withMessage('Invalid handle format')
];

const idParamRules = [
  param('id')
    .isInt({ min: 1 })
    .withMessage('Invalid ID')
];

module.exports = {
  validate,
  handleRules,
  questionRules,
  answerRules,
  authRules,
  handleParamRules,
  idParamRules
}; 


================================================
FILE: backend/src/routes/answers.js
================================================
const express = require('express');
const { statements } = require('../utils/database');
const { authenticate, optionalAuth } = require('../middleware/auth');
const { validate, handleParamRules, idParamRules } = require('../middleware/validation');

const router = express.Router();

// Helper function to transform snake_case to camelCase
const transformAnswer = (answer) => ({
  id: answer.id,
  questionId: answer.question_id,
  userId: answer.user_id,
  questionText: answer.question_text,
  answerText: answer.answer_text,
  createdAt: answer.created_at,
  updatedAt: answer.updated_at
});

// Get a single answer by ID (public)
router.get('/single/:id', idParamRules, validate, async (req, res) => {
  try {
    const answerId = parseInt(req.params.id);
    
    // Get the answer with user info
    const answer = await statements.getAnswerById.get(answerId);
    
    if (!answer) {
      return res.status(404).json({ message: 'Answer not found' });
    }
    
    // Get user info
    const user = await statements.getUserById.get(answer.user_id);
    
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Transform and add user info
    const transformedAnswer = transformAnswer(answer);
    transformedAnswer.userHandle = user.handle;
    transformedAnswer.userName = user.twitter_name;
    transformedAnswer.userProfileImage = user.twitter_profile_image;
    transformedAnswer.userAuthType = user.auth_type;
    
    res.json(transformedAnswer);
  } catch (error) {
    console.error('Get single answer error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Get answers by handle (public)
router.get('/:handle', handleParamRules, validate, async (req, res) => {
  try {
    const { handle } = req.params;
    const page = parseInt(req.query.page) || 1;
    const limit = Math.min(parseInt(req.query.limit) || 20, 100); // Max 100 per page
    const offset = (page - 1) * limit;
    
    console.log('📖 Getting answers for handle:', handle);
    
    // Get user by handle
    const user = await statements.getUserByHandle.get(handle);
    if (!user) {
      return res.status(404).json({ message: 'Handle not found' });
    }
    
    console.log('👤 Found user:', { id: user.id, handle: user.handle });
    
    // Get answers
    const answers = await statements.getAnswersByUserId.all(user.id, limit, offset);
    const totalCount = await statements.countAnswersByUserId.get(user.id);
    
    console.log('💬 Found answers:', { count: answers.length, total: totalCount.count });
    
    // Transform to camelCase
    const transformedAnswers = answers.map(transformAnswer);
    
    res.json({
      answers: transformedAnswers,
      total: totalCount.count,
      page,
      pages: Math.ceil(totalCount.count / limit)
    });
  } catch (error) {
    console.error('Get answers error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Delete an answer (requires auth)
router.delete('/:id', authenticate, idParamRules, validate, async (req, res) => {
  try {
    const answerId = parseInt(req.params.id);
    
    // Delete answer (only if user owns it)
    const result = await statements.deleteAnswer.run(answerId, req.user.id);
    
    if (result.changes === 0) {
      return res.status(404).json({ message: 'Answer not found or unauthorized' });
    }
    
    res.json({ message: 'Answer deleted successfully' });
  } catch (error) {
    console.error('Delete answer error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Edit an answer (requires auth)
router.put('/:id', authenticate, idParamRules, validate, async (req, res) => {
  try {
    const answerId = parseInt(req.params.id);
    const { answerText } = req.body;
    
    // Validate answer text
    if (!answerText || answerText.trim().length === 0) {
      return res.status(400).json({ message: 'Answer text is required' });
    }
    
    if (answerText.length > 1000) {
      return res.status(400).json({ message: 'Answer must be less than 1000 characters' });
    }
    
    // Update answer (only if user owns it)
    const result = await statements.updateAnswer.run(answerText.trim(), answerId, req.user.id);
    
    if (result.changes === 0) {
      return res.status(404).json({ message: 'Answer not found or unauthorized' });
    }
    
    res.json({ message: 'Answer updated successfully' });
  } catch (error) {
    console.error('Update answer error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

module.exports = router; 


================================================
FILE: backend/src/routes/questions.js
================================================
const express = require('express');
const { statements, db } = require('../utils/database');
const { authenticate } = require('../middleware/auth');
const { validate, questionRules, answerRules, handleParamRules, idParamRules } = require('../middleware/validation');

const router = express.Router();

// Helper function to transform snake_case to camelCase
const transformQuestion = (question) => ({
  id: question.id,
  userId: question.user_id,
  text: question.text,
  ipAddress: question.ip_address,
  createdAt: question.created_at
});

// Ask a question (anonymous)
router.post('/:handle', handleParamRules, questionRules, validate, async (req, res) => {
  try {
    const { handle } = req.params;
    const { text } = req.body;
    
    // Get user by handle
    const user = await statements.getUserByHandle.get(handle);
    if (!user) {
      return res.status(404).json({ message: 'Handle not found' });
    }
    
    // Get IP address for rate limiting
    const ipAddress = req.ip || req.connection.remoteAddress;
    
    // Create question
    const result = await statements.createQuestion.run({
      user_id: user.id,
      text: text.trim(),
      ip_address: ipAddress
    });
    
    res.status(201).json({
      message: 'Question sent successfully',
      questionId: result.lastInsertRowid
    });
  } catch (error) {
    console.error('Ask question error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Get unanswered questions for a handle (requires auth)
router.get('/:handle/unanswered', authenticate, handleParamRules, validate, async (req, res) => {
  try {
    const { handle } = req.params;
    
    // Verify user owns this handle
    if (req.user.handle !== handle) {
      return res.status(403).json({ message: 'Unauthorized' });
    }
    
    // Get unanswered questions
    const questions = await statements.getUnansweredQuestions.all(req.user.id);
    
    // Transform to camelCase
    const transformedQuestions = questions.map(transformQuestion);
    
    res.json(transformedQuestions);
  } catch (error) {
    console.error('Get questions error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Answer a question (requires auth)
router.post('/:id/answer', authenticate, idParamRules, answerRules, validate, async (req, res) => {
  try {
    const questionId = parseInt(req.params.id);
    const { answerText } = req.body;
    
    console.log('📝 Answering question:', { questionId, userId: req.user.id, answerText });
    
    let answerId;
    
    // Run transaction
    const transaction = db.transaction(async () => {
      // Get question
      const question = await statements.getQuestionById.get(questionId);
      if (!question) {
        throw new Error('Question not found');
      }
      
      console.log('❓ Found question:', question);
      
      // Verify user owns this question
      if (question.user_id !== req.user.id) {
        throw new Error('Unauthorized');
      }
      
      // Create answer
      const result = await statements.createAnswer.run({
        question_id: questionId,
        user_id: req.user.id,
        question_text: question.text,
        answer_text: answerText.trim()
      });
      
      answerId = result.lastInsertRowid;
      console.log('✅ Answer created with ID:', answerId);
      
      // Delete the question (it's been answered)
      await statements.deleteQuestion.run(questionId);
      console.log('🗑️ Question deleted');
    });
    
    await transaction();
    
    res.status(201).json({
      message: 'Answer posted successfully',
      answerId: answerId
    });
  } catch (error) {
    console.error('Answer question error:', error);
    
    if (error.message === 'Question not found') {
      return res.status(404).json({ message: 'Question not found' });
    }
    if (error.message === 'Unauthorized') {
      return res.status(403).json({ message: 'Unauthorized' });
    }
    
    res.status(500).json({ message: 'Server error' });
  }
});

// Delete a question (requires auth)
router.delete('/:id', authenticate, idParamRules, validate, async (req, res) => {
  try {
    const questionId = parseInt(req.params.id);
    
    // Get question
    const question = await statements.getQuestionById.get(questionId);
    if (!question) {
      return res.status(404).json({ message: 'Question not found' });
    }
    
    // Verify user owns this question
    if (question.user_id !== req.user.id) {
      return res.status(403).json({ message: 'Unauthorized' });
    }
    
    // Delete question
    await statements.deleteQuestion.run(questionId);
    
    res.json({ message: 'Question deleted successfully' });
  } catch (error) {
    console.error('Delete question error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

module.exports = router; 


================================================
FILE: backend/src/routes/stats.js
================================================
const express = require('express');
const { statements } = require('../utils/database');
const { authenticate } = require('../middleware/auth');
const { validate, handleParamRules } = require('../middleware/validation');

const router = express.Router();

// Get stats for a handle (requires auth)
router.get('/:handle', authenticate, handleParamRules, validate, async (req, res) => {
  try {
    const { handle } = req.params;
    
    // Verify user owns this handle
    if (req.user.handle !== handle) {
      return res.status(403).json({ message: 'Unauthorized' });
    }
    
    // Get stats
    const stats = await statements.getUserStats.get(req.user.id, req.user.id);
    
    res.json({
      handle,
      totalQuestions: stats.total_questions,
      totalAnswers: stats.total_answers,
      unansweredQuestions: stats.total_questions - stats.total_answers
    });
  } catch (error) {
    console.error('Get stats error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

module.exports = router; 


================================================
FILE: backend/src/routes/telegram.js
================================================
const express = require('express');
const { statements } = require('../utils/database');
const { authenticate } = require('../middleware/auth');
const telegramService = require('../utils/telegram');

const router = express.Router();

// In-memory store for connection tokens (in production, use Redis)
const connectionTokens = new Map();

// Generate connection link for authenticated user
router.post('/connect', authenticate, async (req, res) => {
  try {
    const userId = req.user.id;
    
    // Check if already connected
    if (req.user.telegram_chat_id) {
      return res.status(400).json({ 
        message: 'Telegram already connected',
        connected: true 
      });
    }
    
    // Generate connection token
    const tokenData = telegramService.generateConnectionToken(userId);
    connectionTokens.set(tokenData.token, tokenData);
    
    // Clean up expired tokens
    for (const [token, data] of connectionTokens) {
      if (Date.now() > data.expiresAt) {
        connectionTokens.delete(token);
      }
    }
    
    // Generate bot link
    const botUsername = process.env.TELEGRAM_BOT_USERNAME || 'traderfm_bot';
    const connectUrl = `https://t.me/${botUsername}?start=${tokenData.token}`;
    
    res.json({
      connectUrl,
      expiresIn: 600 // 10 minutes
    });
  } catch (error) {
    console.error('Generate connect link error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Disconnect Telegram
router.post('/disconnect', authenticate, async (req, res) => {
  try {
    await statements.updateUserTelegramId.run(req.user.id, null);
    res.json({ message: 'Telegram disconnected successfully' });
  } catch (error) {
    console.error('Disconnect error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Telegram webhook endpoint
router.post('/webhook', async (req, res) => {
  try {
    const update = req.body;
    const result = await telegramService.processUpdate(update);
    
    if (result.action === 'connect' && result.token) {
      // Validate token
      const tokenData = connectionTokens.get(result.token);
      
      if (telegramService.validateConnectionToken(result.token, tokenData)) {
        // Update user with telegram chat ID
        await statements.updateUserTelegramId.run(tokenData.userId, result.chatId);
        
        // Get user info
        const user = await statements.getUserById.get(tokenData.userId);
        
        // Send success message
        await telegramService.sendNotification(result.chatId, 
          `✅ Success! Your trader.fm account (@${user.handle}) is now connected.

You'll receive notifications here whenever someone asks you a question.

Happy answering! 🎯`
        );
        
        // Clean up token
        connectionTokens.delete(result.token);
      } else {
        await telegramService.sendNotification(result.chatId, 
          '❌ Invalid or expired connection link. Please generate a new one from your trader.fm inbox.'
        );
      }
    } else if (result.action === 'disconnect') {
      // Find user by telegram chat ID
      const user = await statements.getUserByTelegramId.get(result.chatId);
      
      if (user) {
        await statements.updateUserTelegramId.run(user.id, null);
        await telegramService.sendNotification(result.chatId, 
          '👋 Notifications disconnected. You can reconnect anytime from your trader.fm inbox.'
        );
      } else {
        await telegramService.sendNotification(result.chatId, 
          '❓ No connected account found.'
        );
      }
    }
    
    res.json({ ok: true });
  } catch (error) {
    console.error('Webhook error:', error);
    res.json({ ok: true }); // Always return 200 to Telegram
  }
});

// Get connection status
router.get('/status', authenticate, async (req, res) => {
  try {
    res.json({
      connected: !!req.user.telegram_chat_id,
      botUsername: process.env.TELEGRAM_BOT_USERNAME || 'traderfm_bot'
    });
  } catch (error) {
    console.error('Status error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

module.exports = router; 


================================================
FILE: backend/src/routes/twitter-auth.js
================================================
const express = require('express');
const passport = require('passport');
const TwitterStrategy = require('passport-twitter').Strategy;
const { statements } = require('../utils/database');
const { generateToken } = require('../middleware/auth');

const router = express.Router();

// Configure Twitter OAuth strategy (OAuth 1.0a)
passport.use(new TwitterStrategy({
  consumerKey: process.env.TWITTER_API_KEY,
  consumerSecret: process.env.TWITTER_API_SECRET,
  callbackURL: process.env.TWITTER_CALLBACK_URL || `${process.env.BASE_URL}/api/auth/twitter/callback`,
  passReqToCallback: false
}, async (token, tokenSecret, profile, done) => {
  try {
    global.logger?.log('🐦 Twitter OAuth callback received');
    global.logger?.log(`👤 Twitter profile: ${JSON.stringify(profile, null, 2)}`);
    
    const twitterId = profile.id;
    const twitterUsername = profile.username;
    const twitterName = profile.displayName;
    const profileImage = profile.photos?.[0]?.value || null;
    
    // Check if user already exists with this Twitter ID
    let user;
    try {
      user = await statements.getUserByTwitterId.get(twitterId);
    } catch (error) {
      global.logger?.error('❌ Error checking for existing Twitter user:', error);
      // If the error is about missing column, the migration hasn't run yet
      if (error.message?.includes('no such column')) {
        return done(new Error('Database migration required. Please restart the application.'), null);
      }
      throw error;
    }
    
    if (user) {
      global.logger?.log(`✅ Existing Twitter user found: ${user.handle}`);
      return done(null, user);
    }
    
    // Check if handle (same as Twitter username) already exists
    const existingUser = await statements.getUserByHandle.get(twitterUsername);
    let finalHandle = twitterUsername;
    
    if (existingUser) {
      // Generate a unique handle by appending timestamp
      finalHandle = `${twitterUsername}_${Date.now()}`;
      global.logger?.log(`📝 Handle collision, using: ${finalHandle}`);
    }
    
    // Create new user
    const result = await statements.createTwitterUser.run({
      handle: finalHandle,
      twitter_id: twitterId,
      twitter_username: twitterUsername,
      twitter_name: twitterName,
      twitter_profile_image: profileImage
    });
    
    user = {
      id: result.lastInsertRowid,
      handle: finalHandle,
      twitter_id: twitterId,
      twitter_username: twitterUsername,
      twitter_name: twitterName,
      twitter_profile_image: profileImage,
      auth_type: 'twitter'
    };
    
    global.logger?.log(`🎉 New Twitter user created: ${finalHandle}`);
    return done(null, user);
    
  } catch (error) {
    global.logger?.error('❌ Twitter OAuth error:', error);
    return done(error, null);
  }
}));

// Session serialization for Twitter OAuth 1.0a
passport.serializeUser((user, done) => {
  done(null, user.id);
});

passport.deserializeUser(async (id, done) => {
  try {
    const user = await statements.getUserById.get(id);
    done(null, user);
  } catch (error) {
    done(error, null);
  }
});

// Start Twitter OAuth flow
router.get('/twitter', (req, res, next) => {
  global.logger?.log('🐦 Starting Twitter OAuth flow...');
  passport.authenticate('twitter')(req, res, next);
});

// Twitter OAuth callback
router.get('/twitter/callback', passport.authenticate('twitter', {
  failureRedirect: process.env.NODE_ENV === 'production' 
    ? '/?error=twitter_auth_failed'
    : `${process.env.FRONTEND_URL || 'http://localhost:3000'}?error=twitter_auth_failed`
}), (req, res) => {
  try {
    // Generate JWT token
    const token = generateToken(req.user.id, req.user.handle);
    
    // Redirect to frontend with token
    // In production on Railway, use the host from the request
    let redirectUrl;
    
    if (process.env.NODE_ENV === 'production') {
      // Use the same domain as the request
      const host = req.get('host');
      const protocol = req.get('x-forwarded-proto') || req.protocol;
      redirectUrl = `${protocol}://${host}/?token=${encodeURIComponent(token)}&handle=${encodeURIComponent(req.user.handle)}&auth_type=twitter`;
    } else {
      // Development mode
      const baseUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
      redirectUrl = `${baseUrl}/?token=${encodeURIComponent(token)}&handle=${encodeURIComponent(req.user.handle)}&auth_type=twitter`;
    }
    
    global.logger?.log(`🔄 Redirecting to: ${redirectUrl}`);
    
    // Clear session after successful authentication (we only need it for OAuth flow)
    req.logout((err) => {
      if (err) {
        global.logger?.error('❌ Session logout error:', err);
      }
      res.redirect(redirectUrl);
    });
      } catch (error) {
      global.logger?.error('❌ Twitter callback error:', error);
      const errorRedirect = process.env.NODE_ENV === 'production'
        ? '/?error=token_generation_failed'
        : `${process.env.FRONTEND_URL || 'http://localhost:3000'}?error=token_generation_failed`;
      res.redirect(errorRedirect);
    }
});

module.exports = router; 


================================================
FILE: backend/src/routes/users.js
================================================
const express = require('express');
const bcrypt = require('bcryptjs');
const { v4: uuidv4 } = require('uuid');
const { statements } = require('../utils/database');
const { generateToken } = require('../middleware/auth');
const { validate, handleRules, authRules, handleParamRules } = require('../middleware/validation');

const router = express.Router();

// Get all public users for directory
router.get('/directory', async (req, res) => {
  try {
    global.logger?.log('📁 Fetching user directory');
    
    // Get all users with basic info (excluding sensitive data)
    const users = await statements.getAllUsers.all();
    
    global.logger?.log(`✅ Found ${users.length} users for directory`);
    res.json({ users: users || [] });
    
  } catch (error) {
    global.logger?.error('❌ Directory fetch error:', error);
    res.status(500).json({ message: 'Server error', users: [] });
  }
});

// Check if handle exists
router.get('/check/:handle', handleParamRules, validate, async (req, res) => {
  try {
    const { handle } = req.params;
    global.logger?.log(`🔍 Checking handle: ${handle}`);
    const user = await statements.getUserByHandle.get(handle);
    
    if (!user) {
      global.logger?.log(`❌ Handle not found: ${handle}`);
      return res.status(404).json({ message: 'Handle not found' });
    }
    
    global.logger?.log(`✅ Handle exists: ${handle}`);
    
    // Return public profile info for Twitter users
    const publicInfo = {
      exists: true,
      handle: user.handle,
      auth_type: user.auth_type
    };
    
    if (user.auth_type === 'twitter') {
      publicInfo.twitter_username = user.twitter_username;
      publicInfo.twitter_name = user.twitter_name;
      publicInfo.twitter_profile_image = user.twitter_profile_image;
    }
    
    res.json(publicInfo);
  } catch (error) {
    global.logger?.error('❌ Check handle error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Create new handle
router.post('/create', handleRules, validate, async (req, res) => {
  try {
    global.logger?.log('🚀 Starting user creation...');
    const { handle } = req.body;
    global.logger?.log(`👤 Creating handle: ${handle}`);
    
    // Check if handle already exists
    global.logger?.log('🔍 Checking if handle exists...');
    const existingUser = await statements.getUserByHandle.get(handle);
    if (existingUser) {
      global.logger?.log(`❌ Handle already exists: ${handle}`);
      return res.status(400).json({ message: 'Handle already exists' });
    }
    global.logger?.log('✅ Handle is available');
    
    // Generate secret key
    global.logger?.log('🔑 Generating secret key...');
    const secretKey = uuidv4();
    global.logger?.log('✅ Secret key generated');
    
    // Hash the secret key
    global.logger?.log('🔐 Hashing secret key...');
    const hashedSecretKey = await bcrypt.hash(secretKey, 10);
    global.logger?.log('✅ Secret key hashed');
    
    // Create user
    global.logger?.log('💾 Creating user in database...');
    const result = await statements.createUser.run({
      handle,
      secret_key: hashedSecretKey
    });
    global.logger?.log(`✅ User created successfully: ${JSON.stringify(result)}`);
    
    res.status(201).json({
      message: 'Handle created successfully',
      handle,
      secretKey // Only sent once during creation
    });
    global.logger?.log(`🎉 User creation completed for: ${handle}`);
  } catch (error) {
    global.logger?.error('❌ Create handle error:', error);
    global.logger?.error(`❌ Error stack: ${error.stack}`);
    global.logger?.error(`❌ Error details: ${JSON.stringify({
      name: error.name,
      message: error.message,
      code: error.code,
      errno: error.errno
    })}`);
    res.status(500).json({ message: 'Server error', error: error.message });
  }
});

// Authenticate user
router.post('/auth', authRules, validate, async (req, res) => {
  try {
    global.logger?.log('🔐 Starting authentication...');
    const { handle, secretKey } = req.body;
    global.logger?.log(`👤 Authenticating handle: ${handle}`);
    
    // Get user
    const user = await statements.getUserByHandle.get(handle);
    if (!user) {
      global.logger?.log(`❌ User not found for auth: ${handle}`);
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    // Check if user is Twitter-only
    if (user.auth_type === 'twitter') {
      global.logger?.log(`❌ User ${handle} is Twitter-only, cannot use secret key auth`);
      return res.status(401).json({ message: 'This account uses Twitter authentication. Please sign in with Twitter.' });
    }
    
    // Verify secret key
    global.logger?.log('🔑 Verifying secret key...');
    const isValid = await bcrypt.compare(secretKey, user.secret_key);
    if (!isValid) {
      global.logger?.log(`❌ Invalid secret key for: ${handle}`);
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    // Generate JWT token
    global.logger?.log('🎫 Generating JWT token...');
    const token = generateToken(user.id, user.handle);
    
    global.logger?.log(`✅ Authentication successful for: ${handle}`);
    res.json({
      message: 'Authentication successful',
      token,
      handle: user.handle,
      authType: user.auth_type
    });
  } catch (error) {
    global.logger?.error('❌ Auth error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

module.exports = router; 


================================================
FILE: backend/src/utils/database.js
================================================
const sqlite3 = require('sqlite3').verbose();
const path = require('path');
const fs = require('fs');
const { promisify } = require('util');
const { runMigrations } = require('./migrations');

// Determine data directory based on environment
const isProduction = process.env.NODE_ENV === 'production';
const dataDir = isProduction 
  ? '/data'  // Railway volume mount point
  : path.join(__dirname, '../../data'); // Local development

// Ensure data directory exists
console.log('📁 Database directory:', dataDir);

try {
  if (!fs.existsSync(dataDir)) {
    console.log('📁 Creating data directory...');
    fs.mkdirSync(dataDir, { recursive: true });
    console.log('✅ Data directory created');
  } else {
    console.log('✅ Data directory exists');
  }
} catch (error) {
  console.error('❌ Failed to create data directory:', error);
}

// Database file path
const dbPath = path.join(dataDir, 'traderfm.db');
console.log('🗄️ Database path:', dbPath);

// Create database connection with error callback
let db;
try {
  db = new sqlite3.Database(dbPath, sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE, (err) => {
    if (err) {
      console.error('❌ Failed to open database:', err);
      console.error('Database path:', dbPath);
      console.error('Directory exists:', fs.existsSync(dataDir));
      console.error('Directory permissions:', fs.existsSync(dataDir) ? fs.statSync(dataDir).mode : 'N/A');
      throw err;
    }
    console.log('✅ SQLite database connection created');
  });
} catch (error) {
  console.error('❌ Failed to create database connection:', error);
  throw error;
}

// Promisify database methods
const runAsync = promisify(db.run.bind(db));
const getAsync = promisify(db.get.bind(db));
const allAsync = promisify(db.all.bind(db));

// Custom run function that properly handles SQLite3 results
const runWithResult = (sql, params) => {
  return new Promise((resolve, reject) => {
    db.run(sql, params, function(err) {
      if (err) {
        reject(err);
      } else {
        resolve({
          lastID: this.lastID,
          changes: this.changes
        });
      }
    });
  });
};

// Initialize database schema
const init = async () => {
  try {
    console.log('🔧 Initializing database schema...');
    
    // Wait for database to be ready
    await new Promise((resolve) => {
      db.on('open', () => {
        console.log('✅ Database is open and ready');
        resolve();
      });
      // If already open, resolve immediately
      if (db.open) {
        resolve();
      }
    });
    
    // Enable foreign keys
    await runAsync('PRAGMA foreign_keys = ON');
    console.log('✅ Foreign keys enabled');

    // Users table
    await runAsync(`
      CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        handle TEXT UNIQUE NOT NULL,
        secret_key TEXT,
        twitter_id TEXT UNIQUE,
        twitter_username TEXT UNIQUE,
        twitter_name TEXT,
        twitter_profile_image TEXT,
        auth_type TEXT DEFAULT 'secret_key' CHECK (auth_type IN ('secret_key', 'twitter')),
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);
    console.log('✅ Users table ready');

    // Questions table
    await runAsync(`
      CREATE TABLE IF NOT EXISTS questions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        text TEXT NOT NULL,
        ip_address TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )
    `);
    console.log('✅ Questions table ready');

    // Answers table
    await runAsync(`
      CREATE TABLE IF NOT EXISTS answers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        question_id INTEGER NOT NULL,
        user_id INTEGER NOT NULL,
        question_text TEXT NOT NULL,
        answer_text TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )
    `);
    console.log('✅ Answers table ready');

    // Create indexes for better performance
    await runAsync('CREATE INDEX IF NOT EXISTS idx_questions_user_id ON questions(user_id)');
    await runAsync('CREATE INDEX IF NOT EXISTS idx_answers_user_id ON answers(user_id)');
    await runAsync('CREATE INDEX IF NOT EXISTS idx_answers_created_at ON answers(created_at)');
    await runAsync('CREATE INDEX IF NOT EXISTS idx_users_handle ON users(handle)');
    console.log('✅ Database indexes created');

    // Create triggers to update the updated_at timestamp
    await runAsync(`
      CREATE TRIGGER IF NOT EXISTS update_users_timestamp 
      AFTER UPDATE ON users
      BEGIN
        UPDATE users SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
      END
    `);
    console.log('✅ Database triggers created');

    // Run migrations AFTER tables are created to update existing databases
    await runMigrations(db);

    console.log('🎉 Database schema initialized successfully');
  } catch (error) {
    console.error('❌ Database initialization error:', error);
    throw error;
  }
};

// Helper functions for database operations with error handling
const dbOperations = {
  // User operations
  createUser: async (handle, secretKey) => {
    try {
      const result = await runWithResult(
        'INSERT INTO users (handle, secret_key, auth_type) VALUES (?, ?, ?)',
        [handle, secretKey, 'secret_key']
      );
      return { lastInsertRowid: result.lastID };
    } catch (error) {
      console.error('❌ createUser error:', error);
      throw error;
    }
  },

  createTwitterUser: async (handle, twitterId, twitterUsername, twitterName, profileImage) => {
    try {
      const result = await runWithResult(
        'INSERT INTO users (handle, twitter_id, twitter_username, twitter_name, twitter_profile_image, auth_type) VALUES (?, ?, ?, ?, ?, ?)',
        [handle, twitterId, twitterUsername, twitterName, profileImage, 'twitter']
      );
      return { lastInsertRowid: result.lastID };
    } catch (error) {
      console.error('❌ createTwitterUser error:', error);
      throw error;
    }
  },

  getUserByTwitterId: async (twitterId) => {
    try {
      return await getAsync('SELECT * FROM users WHERE twitter_id = ?', [twitterId]);
    } catch (error) {
      console.error('❌ getUserByTwitterId error:', error);
      throw error;
    }
  },

  getUserByHandle: async (handle) => {
    try {
      return await getAsync('SELECT * FROM users WHERE handle = ?', [handle]);
    } catch (error) {
      console.error('❌ getUserByHandle error:', error);
      throw error;
    }
  },

  getUserById: async (id) => {
    try {
      return await getAsync('SELECT * FROM users WHERE id = ?', [id]);
    } catch (error) {
      console.error('❌ getUserById error:', error);
      throw error;
    }
  },

  // Question operations
  createQuestion: async (userId, text, ipAddress) => {
    try {
      const result = await runWithResult(
        'INSERT INTO questions (user_id, text, ip_address) VALUES (?, ?, ?)',
        [userId, text, ipAddress]
      );
      return { lastInsertRowid: result.lastID };
    } catch (error) {
      console.error('❌ createQuestion error:', error);
      throw error;
    }
  },

  getUnansweredQuestions: async (userId) => {
    try {
      return await allAsync(`
        SELECT q.* FROM questions q
        LEFT JOIN answers a ON q.id = a.question_id
        WHERE q.user_id = ? AND a.id IS NULL
        ORDER BY q.created_at DESC
      `, [userId]);
    } catch (error) {
      console.error('❌ getUnansweredQuestions error:', error);
      throw error;
    }
  },

  getQuestionById: async (id) => {
    try {
      return await getAsync('SELECT * FROM questions WHERE id = ?', [id]);
    } catch (error) {
      console.error('❌ getQuestionById error:', error);
      throw error;
    }
  },

  deleteQuestion: async (id) => {
    try {
      const result = await runWithResult('DELETE FROM questions WHERE id = ?', [id]);
      return { changes: result.changes };
    } catch (error) {
      console.error('❌ deleteQuestion error:', error);
      throw error;
    }
  },

  // Answer operations
  createAnswer: async (questionId, userId, questionText, answerText) => {
    try {
      const result = await runWithResult(
        'INSERT INTO answers (question_id, user_id, question_text, answer_text) VALUES (?, ?, ?, ?)',
        [questionId, userId, questionText, answerText]
      );
      return { lastInsertRowid: result.lastID };
    } catch (error) {
      console.error('❌ createAnswer error:', error);
      throw error;
    }
  },

  getAnswersByUserId: async (userId, limit, offset) => {
    try {
      return await allAsync(
        'SELECT * FROM answers WHERE user_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?',
        [userId, limit, offset]
      );
    } catch (error) {
      console.error('❌ getAnswersByUserId error:', error);
      throw error;
    }
  },

  getAnswerById: async (id) => {
    try {
      return await getAsync('SELECT * FROM answers WHERE id = ?', [id]);
    } catch (error) {
      console.error('❌ getAnswerById error:', error);
      throw error;
    }
  },

  countAnswersByUserId: async (userId) => {
    try {
      return await getAsync(
        'SELECT COUNT(*) as count FROM answers WHERE user_id = ?',
        [userId]
      );
    } catch (error) {
      console.error('❌ countAnswersByUserId error:', error);
      throw error;
    }
  },

  deleteAnswer: async (id, userId) => {
    try {
      const result = await runWithResult(
        'DELETE FROM answers WHERE id = ? AND user_id = ?',
        [id, userId]
      );
      return { changes: result.changes };
    } catch (error) {
      console.error('❌ deleteAnswer error:', error);
      throw error;
    }
  },

  // Update answer
  updateAnswer: async (answerText, id, userId) => {
    try {
      const result = await runWithResult(
        'UPDATE answers SET answer_text = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ? AND user_id = ?',
        [answerText, id, userId]
      );
      return { changes: result.changes };
    } catch (error) {
      console.error('❌ updateAnswer error:', error);
      throw error;
    }
  },

  // Stats operations
  getUserStats: async (userId) => {
    try {
      return await getAsync(`
        SELECT 
          (SELECT COUNT(*) FROM questions WHERE user_id = ?) as total_questions,
          (SELECT COUNT(*) FROM answers WHERE user_id = ?) as total_answers
      `, [userId, userId]);
    } catch (error) {
      console.error('❌ getUserStats error:', error);
      throw error;
    }
  },

  // Get all users for directory
  getAllUsers: async () => {
    try {
      return await allAsync(`
        SELECT 
          users.id,
          users.handle, 
          users.twitter_username, 
          users.twitter_name, 
          users.twitter_profile_image,
          users.auth_type,
          users.created_at,
          COUNT(DISTINCT answers.id) as answer_count
        FROM users 
        LEFT JOIN answers ON users.id = answers.user_id
        GROUP BY users.id
        ORDER BY users.created_at DESC 
        LIMIT 50
      `);
    } catch (error) {
      console.error('❌ getAllUsers error:', error);
      throw error;
    }
  },

  // Get recent questions
  getRecentQuestions: async (since) => {
    try {
      return await allAsync(`
        SELECT 
          q.id,
          q.text,
          q.created_at,
          u.handle as user_handle
        FROM questions q
        JOIN users u ON q.user_id = u.id
        WHERE q.created_at > ?
        ORDER BY q.created_at DESC
        LIMIT 10
      `, [since]);
    } catch (error) {
      console.error('❌ getRecentQuestions error:', error);
      throw error;
    }
  },

  // Get recent answers
  getRecentAnswers: async (since) => {
    try {
      return await allAsync(`
        SELECT 
          a.id,
          a.question_text,
          a.answer_text,
          a.created_at,
          u.handle as user_handle,
          u.twitter_profile_image
        FROM answers a
        JOIN users u ON a.user_id = u.id
        WHERE a.created_at > ?
        ORDER BY a.created_at DESC
        LIMIT 10
      `, [since]);
    } catch (error) {
      console.error('❌ getRecentAnswers error:', error);
      throw error;
    }
  },

  // Get recent users
  getRecentUsers: async (since) => {
    try {
      return await allAsync(`
        SELECT 
          id,
          handle,
          twitter_username,
          twitter_name,
          twitter_profile_image,
          auth_type,
          created_at
        FROM users
        WHERE created_at > ?
        ORDER BY created_at DESC
        LIMIT 10
      `, [since]);
    } catch (error) {
      console.error('❌ getRecentUsers error:', error);
      throw error;
    }
  },

  // Telegram operations
  updateUserTelegramId: async (userId, telegramChatId) => {
    try {
      const result = await runWithResult(
        'UPDATE users SET telegram_chat_id = ? WHERE id = ?',
        [telegramChatId, userId]
      );
      return { changes: result.changes };
    } catch (error) {
      console.error('❌ updateUserTelegramId error:', error);
      throw error;
    }
  },

  getUserByTelegramId: async (telegramChatId) => {
    try {
      return await getAsync('SELECT * FROM users WHERE telegram_chat_id = ?', [telegramChatId]);
    } catch (error) {
      console.error('❌ getUserByTelegramId error:', error);
      throw error;
    }
  },

  // Transaction helper
  runTransaction: async (callback) => {
    await runAsync('BEGIN TRANSACTION');
    try {
      await callback();
      await runAsync('COMMIT');
    } catch (error) {
      await runAsync('ROLLBACK');
      throw error;
    }
  }
};

// Wrap all operations to match the original API
const statements = {
  createUser: {
    run: (params) => dbOperations.createUser(params.handle, params.secret_key)
  },
  createTwitterUser: {
    run: (params) => dbOperations.createTwitterUser(params.handle, params.twitter_id, params.twitter_username, params.twitter_name, params.twitter_profile_image)
  },
  getUserByHandle: {
    get: (handle) => dbOperations.getUserByHandle(handle)
  },
  getUserById: {
    get: (id) => dbOperations.getUserById(id)
  },
  getUserByTwitterId: {
    get: (twitterId) => dbOperations.getUserByTwitterId(twitterId)
  },
  createQuestion: {
    run: (params) => dbOperations.createQuestion(params.user_id, params.text, params.ip_address)
  },
  getUnansweredQuestions: {
    all: (userId) => dbOperations.getUnansweredQuestions(userId)
  },
  getQuestionById: {
    get: (id) => dbOperations.getQuestionById(id)
  },
  deleteQuestion: {
    run: (id) => dbOperations.deleteQuestion(id)
  },
  createAnswer: {
    run: (params) => dbOperations.createAnswer(params.question_id, params.user_id, params.question_text, params.answer_text)
  },
  getAnswersByUserId: {
    all: (userId, limit, offset) => dbOperations.getAnswersByUserId(userId, limit, offset)
  },
  getAnswerById: {
    get: (id) => dbOperations.getAnswerById(id)
  },
  countAnswersByUserId: {
    get: (userId) => dbOperations.countAnswersByUserId(userId)
  },
  deleteAnswer: {
    run: (id, userId) => dbOperations.deleteAnswer(id, userId)
  },
  updateAnswer: {
    run: (answerText, id, userId) => dbOperations.updateAnswer(answerText, id, userId)
  },
  getUserStats: {
    get: (userId1, userId2) => dbOperations.getUserStats(userId1)
  },
  getAllUsers: {
    all: () => dbOperations.getAllUsers()
  },
  getRecentQuestions: {
    all: (since) => dbOperations.getRecentQuestions(since)
  },
  getRecentAnswers: {
    all: (since) => dbOperations.getRecentAnswers(since)
  },
  getRecentUsers: {
    all: (since) => dbOperations.getRecentUsers(since)
  },
  updateUserTelegramId: {
    run: (userId, telegramChatId) => dbOperations.updateUserTelegramId(userId, telegramChatId)
  },
  getUserByTelegramId: {
    get: (telegramChatId) => dbOperations.getUserByTelegramId(telegramChatId)
  }
};

module.exports = {
  db: {
    transaction: (callback) => {
      return () => dbOperations.runTransaction(callback);
    }
  },
  init,
  statements
}; 


================================================
FILE: backend/src/utils/initDb.js
================================================
#!/usr/bin/env node

const { init } = require('./database');

console.log('Initializing database...');

init()
  .then(() => {
    console.log('Database initialized successfully!');
    process.exit(0);
  })
  .catch((error) => {
    console.error('Failed to initialize database:', error);
    process.exit(1);
  }); 


================================================
FILE: backend/src/utils/migrations.js
================================================
const sqlite3 = require('sqlite3').verbose();
const path = require('path');
const fs = require('fs');

// Migration functions
const migrations = [
  {
    version: 1,
    description: 'Add Twitter OAuth columns to users table',
    up: async (db) => {
      console.log('🔄 Running migration 1: Add Twitter OAuth columns...');
      
      // Check if users table exists
      const tableExists = await new Promise((resolve, reject) => {
        db.get("SELECT name FROM sqlite_master WHERE type='table' AND name='users'", (err, row) => {
          if (err) reject(err);
          else resolve(!!row);
        });
      });
      
      if (!tableExists) {
        console.log('✓ Users table does not exist yet, skipping migration');
        return;
      }
      
      // Check if columns already exist
      const tableInfo = await new Promise((resolve, reject) => {
        db.all("PRAGMA table_info(users)", (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });
      
      const columnNames = tableInfo.map(col => col.name);
      
      // If twitter_id already exists, assume this is a fresh database with new schema
      if (columnNames.includes('twitter_id')) {
        console.log('✓ Twitter columns already exist, skipping migration');
        return;
      }
      
      // This is an old database that needs updating
      console.log('📝 Updating existing database with Twitter OAuth columns...');
      
      const columnsToAdd = [
        { name: 'twitter_id', sql: 'ALTER TABLE users ADD COLUMN twitter_id TEXT UNIQUE' },
        { name: 'twitter_username', sql: 'ALTER TABLE users ADD COLUMN twitter_username TEXT UNIQUE' },
        { name: 'twitter_name', sql: 'ALTER TABLE users ADD COLUMN twitter_name TEXT' },
        { name: 'twitter_profile_image', sql: 'ALTER TABLE users ADD COLUMN twitter_profile_image TEXT' },
        { name: 'auth_type', sql: "ALTER TABLE users ADD COLUMN auth_type TEXT DEFAULT 'secret_key'" }
      ];
      
      for (const column of columnsToAdd) {
        if (!columnNames.includes(column.name)) {
          await new Promise((resolve, reject) => {
            db.run(column.sql, (err) => {
              if (err) {
                console.error(`❌ Failed to add column ${column.name}:`, err);
                reject(err);
              } else {
                console.log(`✅ Added column: ${column.name}`);
                resolve();
              }
            });
          });
        }
      }
      
      // Update existing users to have auth_type = 'secret_key' if they have a secret_key
      await new Promise((resolve, reject) => {
        db.run("UPDATE users SET auth_type = 'secret_key' WHERE secret_key IS NOT NULL AND auth_type IS NULL", (err) => {
          if (err) reject(err);
          else resolve();
        });
      });
      
      console.log('✅ Migration 1 completed');
    }
  },
  {
    version: 2,
    description: 'Fix answers table foreign key constraint',
    up: async (db) => {
      console.log('🔄 Running migration 2: Fix answers table foreign key constraint...');
      
      // Check if answers table exists
      const tableExists = await new Promise((resolve, reject) => {
        db.get("SELECT name FROM sqlite_master WHERE type='table' AND name='answers'", (err, row) => {
          if (err) reject(err);
          else resolve(!!row);
        });
      });
      
      if (!tableExists) {
        console.log('✓ Answers table does not exist yet, skipping migration');
        return;
      }
      
      // SQLite doesn't support dropping constraints, so we need to recreate the table
      console.log('📝 Recreating answers table without question_id foreign key constraint...');
      
      // Start transaction
      await new Promise((resolve, reject) => {
        db.run('BEGIN TRANSACTION', (err) => {
          if (err) reject(err);
          else resolve();
        });
      });
      
      try {
        // Create new table without the problematic foreign key
        await new Promise((resolve, reject) => {
          db.run(`
            CREATE TABLE answers_new (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              question_id INTEGER NOT NULL,
              user_id INTEGER NOT NULL,
              question_text TEXT NOT NULL,
              answer_text TEXT NOT NULL,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            )
          `, (err) => {
            if (err) reject(err);
            else resolve();
          });
        });
        
        // Copy data from old table to new table
        await new Promise((resolve, reject) => {
          db.run(`
            INSERT INTO answers_new (id, question_id, user_id, question_text, answer_text, created_at)
            SELECT id, question_id, user_id, question_text, answer_text, created_at FROM answers
          `, (err) => {
            if (err) reject(err);
            else resolve();
          });
        });
        
        // Drop old table
        await new Promise((resolve, reject) => {
          db.run('DROP TABLE answers', (err) => {
            if (err) reject(err);
            else resolve();
          });
        });
        
        // Rename new table to answers
        await new Promise((resolve, reject) => {
          db.run('ALTER TABLE answers_new RENAME TO answers', (err) => {
            if (err) reject(err);
            else resolve();
          });
        });
        
        // Recreate indexes
        await new Promise((resolve, reject) => {
          db.run('CREATE INDEX IF NOT EXISTS idx_answers_user_id ON answers(user_id)', (err) => {
            if (err) reject(err);
            else resolve();
          });
        });
        
        await new Promise((resolve, reject) => {
          db.run('CREATE INDEX IF NOT EXISTS idx_answers_created_at ON answers(created_at)', (err) => {
            if (err) reject(err);
            else resolve();
          });
        });
        
        // Commit transaction
        await new Promise((resolve, reject) => {
          db.run('COMMIT', (err) => {
            if (err) reject(err);
            else resolve();
          });
        });
        
        console.log('✅ Migration 2 completed successfully');
      } catch (error) {
        // Rollback on error
        await new Promise((resolve) => {
          db.run('ROLLBACK', () => resolve());
        });
        throw error;
      }
    }
  },
  {
    version: 3,
    description: 'Add updated_at column to answers table',
    up: async (db) => {
      console.log('🔄 Running migration 3: Add updated_at column to answers table...');
      
      // Check if answers table exists
      const tableExists = await new Promise((resolve, reject) => {
        db.get("SELECT name FROM sqlite_master WHERE type='table' AND name='answers'", (err, row) => {
          if (err) reject(err);
          else resolve(!!row);
        });
      });
      
      if (!tableExists) {
        console.log('✓ Answers table does not exist yet, skipping migration');
        return;
      }
      
      // Check if column already exists
      const tableInfo = await new Promise((resolve, reject) => {
        db.all("PRAGMA table_info(answers)", (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });
      
      const columnNames = tableInfo.map(col => col.name);
      
      if (columnNames.includes('updated_at')) {
        console.log('✓ updated_at column already exists, skipping migration');
        return;
      }
      
      // Add updated_at column
      await new Promise((resolve, reject) => {
        db.run('ALTER TABLE answers ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP', (err) => {
          if (err) {
            console.error('❌ Failed to add updated_at column:', err);
            reject(err);
          } else {
            console.log('✅ Added updated_at column');
            resolve();
          }
        });
      });
      
      // Set updated_at to created_at for existing records
      await new Promise((resolve, reject) => {
        db.run('UPDATE answers SET updated_at = created_at WHERE updated_at IS NULL', (err) => {
          if (err) reject(err);
          else resolve();
        });
      });
      
      console.log('✅ Migration 3 completed');
    }
  },
  {
    version: 4,
    description: 'Add telegram_chat_id column to users table for notifications',
    up: async (db) => {
      console.log('🔄 Running migration 4: Add telegram_chat_id column to users table...');
      
      // Check if users table exists
      const tableExists = await new Promise((resolve, reject) => {
        db.get("SELECT name FROM sqlite_master WHERE type='table' AND name='users'", (err, row) => {
          if (err) reject(err);
          else resolve(!!row);
        });
      });
      
      if (!tableExists) {
        console.log('✓ Users table does not exist yet, skipping migration');
        return;
      }
      
      // Check if column already exists
      const tableInfo = await new Promise((resolve, reject) => {
        db.all("PRAGMA table_info(users)", (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });
      
      const columnNames = tableInfo.map(col => col.name);
      
      if (columnNames.includes('telegram_chat_id')) {
        console.log('✓ telegram_chat_id column already exists, skipping migration');
        return;
      }
      
      // Add telegram_chat_id column
      await new Promise((resolve, reject) => {
        db.run('ALTER TABLE users ADD COLUMN telegram_chat_id TEXT', (err) => {
          if (err) {
            console.error('❌ Failed to add telegram_chat_id column:', err);
            reject(err);
          } else {
            console.log('✅ Added telegram_chat_id column');
            resolve();
          }
        });
      });
      
      console.log('✅ Migration 4 completed');
    }
  }
];

// Run migrations
async function runMigrations(db) {
  console.log('🔧 Checking for database migrations...');
  
  // Create migrations table if it doesn't exist
  await new Promise((resolve, reject) => {
    db.run(`
      CREATE TABLE IF NOT EXISTS migrations (
        version INTEGER PRIMARY KEY,
        description TEXT,
        applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `, (err) => {
      if (err) reject(err);
      else resolve();
    });
  });
  
  // Get applied migrations
  const appliedMigrations = await new Promise((resolve, reject) => {
    db.all('SELECT version FROM migrations', (err, rows) => {
      if (err) reject(err);
      else resolve(rows.map(r => r.version));
    });
  });
  
  // Run pending migrations
  for (const migration of migrations) {
    if (!appliedMigrations.includes(migration.version)) {
      console.log(`📝 Running migration ${migration.version}: ${migration.description}`);
      
      try {
        await migration.up(db);
        
        // Record migration
        await new Promise((resolve, reject) => {
          db.run(
            'INSERT INTO migrations (version, description) VALUES (?, ?)',
            [migration.version, migration.description],
            (err) => {
              if (err) reject(err);
              else resolve();
            }
          );
        });
        
        console.log(`✅ Migration ${migration.version} applied successfully`);
      } catch (error) {
        console.error(`❌ Migration ${migration.version} failed:`, error);
        throw error;
      }
    }
  }
  
  console.log('✅ All migrations completed');
}

module.exports = { runMigrations }; 


================================================
FILE: backend/src/utils/telegram.js
================================================
const axios = require('axios');
const crypto = require('crypto');

class TelegramService {
  constructor() {
    this.botToken = process.env.TELEGRAM_BOT_TOKEN;
    this.baseURL = `https://api.telegram.org/bot${this.botToken}`;
    this.isEnabled = !!this.botToken;
    
    if (!this.isEnabled) {
      console.log('⚠️ Telegram notifications disabled - TELEGRAM_BOT_TOKEN not set');
    } else {
      console.log('✅ Telegram notifications enabled');
      this.setBotCommands();
    }
  }

  async setBotCommands() {
    try {
      await axios.post(`${this.baseURL}/setMyCommands`, {
        commands: [
          { command: 'start', description: 'Connect your trader.fm account' },
          { command: 'disconnect', description: 'Disconnect notifications' },
          { command: 'help', description: 'Get help' }
        ]
      });
    } catch (error) {
      console.error('Failed to set bot commands:', error.message);
    }
  }

  generateConnectionToken(userId) {
    // Generate a secure token for connecting Telegram to user account
    const token = crypto.randomBytes(32).toString('hex');
    const expiresAt = Date.now() + 10 * 60 * 1000; // 10 minutes
    return { token, userId, expiresAt };
  }

  validateConnectionToken(token, storedToken) {
    if (!storedToken) return false;
    if (storedToken.token !== token) return false;
    if (Date.now() > storedToken.expiresAt) return false;
    return true;
  }

  async sendNotification(chatId, message, options = {}) {
    if (!this.isEnabled) return;

    try {
      const payload = {
        chat_id: chatId,
        text: message,
        parse_mode: 'HTML',
        disable_web_page_preview: true,
        ...options
      };

      const response = await axios.post(`${this.baseURL}/sendMessage`, payload);
      return response.data;
    } catch (error) {
      console.error('Failed to send Telegram notification:', error.message);
      throw error;
    }
  }

  async sendQuestionNotification(chatId, question, userHandle) {
    const message = `
🔔 <b>New Question!</b>

Someone just asked you:
"<i>${this.escapeHtml(question.text)}</i>"

👉 Answer it now: ${process.env.FRONTEND_URL || 'https://trader.fm'}/inbox/${userHandle}

<i>Reply to questions to share your insights with the world!</i>`;

    return this.sendNotification(chatId, message, {
      reply_markup: {
        inline_keyboard: [[
          {
            text: '📝 Answer Now',
            url: `${process.env.FRONTEND_URL || 'https://trader.fm'}/inbox/${userHandle}`
          }
        ]]
      }
    });
  }

  escapeHtml(text) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
  }

  // Process webhook updates from Telegram
  async processUpdate(update) {
    if (update.message?.text) {
      const chatId = update.message.chat.id;
      const text = update.message.text;
      const username = update.message.from.username;

      if (text.startsWith('/start ')) {
        // Handle connection with token
        const token = text.split(' ')[1];
        return { action: 'connect', chatId, token, username };
      } else if (text === '/start') {
        // No token provided
        await this.sendNotification(chatId, 
          `👋 Welcome to trader.fm notifications!

To connect your account:
1. Go to your trader.fm inbox
2. Click on "Connect Telegram" 
3. Follow the link to complete setup

Need help? Visit ${process.env.FRONTEND_URL || 'https://trader.fm'}`
        );
        return { action: 'welcome' };
      } else if (text === '/disconnect') {
        return { action: 'disconnect', chatId };
      } else if (text === '/help') {
        await this.sendNotification(chatId,
          `<b>trader.fm Telegram Bot Help</b>

🔔 Get instant notifications when someone asks you a question

<b>Commands:</b>
/start - Connect your account
/disconnect - Stop notifications
/help - Show this message

<b>Questions?</b> Visit ${process.env.FRONTEND_URL || 'https://trader.fm'}/help`
        );
        return { action: 'help' };
      }
    }
    
    return { action: 'unknown' };
  }
}

module.exports = new TelegramService(); 


================================================
FILE: frontend/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TraderFM - Ask Traders Anything</title>
    <meta name="description" content="Anonymous Q&A platform for traders. Ask questions, get insights." />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html> 


================================================
FILE: frontend/package.json
================================================
{
  "name": "traderfm-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.16.0",
    "axios": "^1.5.1",
    "react-hot-toast": "^2.4.1",
    "@tanstack/react-query": "^4.36.1",
    "date-fns": "^2.30.0",
    "clsx": "^2.0.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.0.4",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.31",
    "tailwindcss": "^3.3.5",
    "vite": "^4.4.11"
  },
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
} 


================================================
FILE: frontend/postcss.config.js
================================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
} 


================================================
FILE: frontend/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
} 


================================================
FILE: frontend/vite.config.js
================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    strictPort: false,
    proxy: {
      '/api': {
        target: 'http://localhost:5001',
        changeOrigin: true,
      }
    }
  }
}) 


================================================
FILE: frontend/src/App.jsx
================================================
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './hooks/useAuth.jsx';
import { useActivity } from './hooks/useActivity.jsx';
import Layout from './components/Layout';
import ErrorBoundary from './components/ErrorBoundary';
import HomePage from './pages/HomePage';
import ProfilePage from './pages/ProfilePage';
import InboxPage from './pages/InboxPage';

// Activity wrapper component
function ActivityWrapper({ children }) {
  useActivity(); // This will handle all the notifications
  return children;
}

function App() {
  return (
    <ErrorBoundary>
      <AuthProvider>
        <ActivityWrapper>
          <Layout>
            <Routes>
              <Route path="/" element={<HomePage />} />
              <Route path="/u/:handle" element={<ProfilePage />} />
              <Route path="/inbox/:handle" element={<InboxPage />} />
              <Route path="*" element={<Navigate to="/" replace />} />
            </Routes>
          </Layout>
        </ActivityWrapper>
      </AuthProvider>
    </ErrorBoundary>
  );
}

export default App; 


================================================
FILE: frontend/src/index.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Toast animations */
@keyframes enter {
  from {
    transform: translateX(400px);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes leave {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(400px);
    opacity: 0;
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-enter {
  animation: enter 0.3s ease-out;
}

.animate-leave {
  animation: leave 0.3s ease-in forwards;
}

.animate-fade-in {
  animation: fadeIn 0.4s ease-out;
}

/* Subtle hover animations */
@layer utilities {
  .hover-lift {
    @apply transition-transform duration-200 hover:-translate-y-0.5;
  }
  
  .active-press {
    @apply active:scale-95 transition-transform duration-100;
  }
} 


================================================
FILE: frontend/src/main.jsx
================================================
import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { Toaster } from 'react-hot-toast'
import App from './App'
import './index.css'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 5 * 60 * 1000, // 5 minutes
    },
  },
})

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>
        <App />
        <Toaster 
          position="top-right"
          toastOptions={{
            duration: 4000,
            style: {
              background: '#363636',
              color: '#fff',
            },
          }}
        />
      </BrowserRouter>
    </QueryClientProvider>
  </React.StrictMode>,
) 


================================================
FILE: frontend/src/components/ErrorBoundary.jsx
================================================
import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen flex items-center justify-center p-4">
          <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-6">
            <div className="flex items-center space-x-3 text-red-600 mb-4">
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
              <h1 className="text-xl font-semibold">Oops! Something went sideways</h1>
            </div>
            
            <p className="text-gray-600 mb-4">
              Don't worry, it happens to the best of us. Let's get you back on track.
            </p>
            
            {process.env.NODE_ENV === 'development' && this.state.error && (
              <details className="mb-4">
                <summary className="cursor-pointer text-sm text-gray-500 hover:text-gray-700">
                  Error details (development only)
                </summary>
                <pre className="mt-2 text-xs bg-gray-100 p-2 rounded overflow-auto">
                  {this.state.error.toString()}
                </pre>
              </details>
            )}
            
            <button
              onClick={() => window.location.reload()}
              className="w-full bg-blue-500 text-white py-2 rounded-lg hover:bg-blue-600 transition active-press"
            >
              Refresh & Try Again
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary; 


================================================
FILE: frontend/src/components/Layout.jsx
================================================
import React from 'react';
import { Link } from 'react-router-dom';

export default function Layout({ children }) {
  return (
    <div className="min-h-screen bg-gray-50">
      <nav className="bg-white border-b sticky top-0 z-50 backdrop-blur-lg bg-white/95">
        <div className="max-w-6xl mx-auto px-4">
          <div className="flex justify-center items-center h-16">
            <Link to="/" className="flex items-center space-x-2 group">
              <span className="text-2xl group-hover:animate-bounce">💬</span>
              <span className="text-xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 bg-clip-text text-transparent">
                TraderFM
              </span>
            </Link>
          </div>
        </div>
      </nav>
      
      <main className="max-w-6xl mx-auto px-4 py-8 animate-fade-in">
        {children}
      </main>
      
      <footer className="bg-white border-t mt-auto">
        <div className="max-w-6xl mx-auto px-4 py-6">
          <p className="text-center text-gray-600 text-sm">
            TraderFM – where traders share wisdom anonymously 
            <span className="text-gray-400 mx-2">•</span>
            <span className="text-gray-400">No signups, just insights</span>
          </p>
        </div>
      </footer>
    </div>
  );
} 


================================================
FILE: frontend/src/components/Loading.jsx
================================================
import React from 'react';

const loadingMessages = [
  "Loading the good stuff...",
  "Fetching insights...",
  "Gathering wisdom...",
  "Almost there...",
  "Preparing your content...",
  "Just a moment...",
  "Loading amazing things..."
];

export default function Loading({ size = 'md', className = '', showMessage = false }) {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12',
  };

  const randomMessage = loadingMessages[Math.floor(Math.random() * loadingMessages.length)];

  return (
    <div className={`flex flex-col justify-center items-center ${className}`}>
      <div className={`${sizeClasses[size]} animate-spin`}>
        <svg className="w-full h-full" viewBox="0 0 24 24">
          <circle 
            className="opacity-25" 
            cx="12" 
            cy="12" 
            r="10" 
            stroke="currentColor" 
            strokeWidth="4"
            fill="none"
          />
          <path 
            className="opacity-75" 
            fill="currentColor" 
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          />
        </svg>
      </div>
      {showMessage && size === 'lg' && (
        <p className="mt-4 text-gray-600 animate-pulse">{randomMessage}</p>
      )}
    </div>
  );
}

export function LoadingPage() {
  return (
    <div className="min-h-screen flex items-center justify-center">
      <Loading size="lg" showMessage />
    </div>
  );
}

export function LoadingOverlay({ message }) {
  const defaultMessage = loadingMessages[Math.floor(Math.random() * loadingMessages.length)];
  
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 flex flex-col items-center space-y-3">
        <Loading size="md" />
        <p className="text-gray-600">{message || defaultMessage}</p>
      </div>
    </div>
  );
} 


================================================
FILE: frontend/src/hooks/useActivity.jsx
================================================
import { useEffect, useRef } from 'react';
import { useQuery } from '@tanstack/react-query';
import toast from 'react-hot-toast';
import axios from 'axios';

// Custom toast with profile image
const ActivityToast = ({ message, imageUrl, handle }) => (
  <div className="flex items-center gap-3">
    {imageUrl && (
      <img 
        src={imageUrl} 
        alt={handle} 
        className="w-8 h-8 rounded-full"
      />
    )}
    <div>
      <p className="text-sm font-medium">{message}</p>
      {handle && <p className="text-xs text-gray-500">@{handle}</p>}
    </div>
  </div>
);

export function useActivity() {
  const seenIds = useRef(new Set());
  const lastCheckRef = useRef(new Date().toISOString());
  
  const { data } = useQuery({
    queryKey: ['activity', lastCheckRef.current],
    queryFn: async () => {
      const response = await axios.get('/api/activity', {
        params: { since: lastCheckRef.current }
      });
      return response.data;
    },
    refetchInterval: 5000, // Poll every 5 seconds
    enabled: true,
  });

  useEffect(() => {
    if (!data) return;

    // Process new questions
    data.questions?.forEach(question => {
      if (!seenIds.current.has(`q-${question.id}`)) {
        seenIds.current.add(`q-${question.id}`);
        
        // Don't show notification for questions older than 10 seconds
        const age = Date.now() - new Date(question.created_at).getTime();
        if (age < 10000) {
          toast.custom((t) => (
            <div className={`${t.visible ? 'animate-enter' : 'animate-leave'} bg-white shadow-lg rounded-lg p-4 max-w-md`}>
              <ActivityToast
                message={`New question for @${question.user_handle}`}
                handle={null}
              />
              <p className="text-xs text-gray-600 mt-1 truncate">"{question.text}"</p>
            </div>
          ), {
            duration: 4000,
            position: 'bottom-right',
          });
        }
      }
    });

    // Process new answers
    data.answers?.forEach(answer => {
      if (!seenIds.current.has(`a-${answer.id}`)) {
        seenIds.current.add(`a-${answer.id}`);
        
        const age = Date.now() - new Date(answer.created_at).getTime();
        if (age < 10000) {
          toast.custom((t) => (
            <div className={`${t.visible ? 'animate-enter' : 'animate-leave'} bg-white shadow-lg rounded-lg p-4 max-w-md`}>
              <ActivityToast
                message={`@${answer.user_handle} just answered`}
                imageUrl={answer.twitter_profile_image}
                handle={answer.user_handle}
              />
              <p className="text-xs text-gray-600 mt-1 truncate">Q: "{answer.question_text}"</p>
            </div>
          ), {
            duration: 5000,
            position: 'bottom-right',
          });
        }
      }
    });

    // Process new users
    data.users?.forEach(user => {
      if (!seenIds.current.has(`u-${user.id}`)) {
        seenIds.current.add(`u-${user.id}`);
        
        const age = Date.now() - new Date(user.created_at).getTime();
        if (age < 10000) {
          toast.custom((t) => (
            <div className={`${t.visible ? 'animate-enter' : 'animate-leave'} bg-white shadow-lg rounded-lg p-4 max-w-md`}>
              <ActivityToast
                message={`${user.twitter_name || user.handle} just joined! 🎉`}
                imageUrl={user.twitter_profile_image}
                handle={user.handle}
              />
            </div>
          ), {
            duration: 6000,
            position: 'bottom-right',
          });
        }
      }
    });

    // Update last check time
    if (data.timestamp) {
      lastCheckRef.current = data.timestamp;
    }

    // Clean up old IDs to prevent memory leak
    if (seenIds.current.size > 1000) {
      const idsArray = Array.from(seenIds.current);
      seenIds.current = new Set(idsArray.slice(-500));
    }
  }, [data]);

  return { activityData: data };
} 


================================================
FILE: frontend/src/hooks/useAuth.jsx
================================================
import { useState, useEffect, createContext, useContext } from 'react';
import { userAPI } from '../services/api';
import toast from 'react-hot-toast';

// Create auth context
const AuthContext = createContext(null);

// Auth provider component
export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // Check for existing auth on mount and handle Twitter OAuth callback
  useEffect(() => {
    // Check URL parameters for Twitter OAuth callback
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    const handle = urlParams.get('handle');
    const authType = urlParams.get('auth_type');
    const error = urlParams.get('error');
    
    if (error) {
      toast.error('Twitter sign-in hit a snag. Try again?');
      // Clean up URL
      window.history.replaceState({}, document.title, window.location.pathname);
      setLoading(false);
      return;
    }
    
    if (token && handle && authType === 'twitter') {
      // Twitter OAuth successful
      localStorage.setItem('auth_token', token);
      localStorage.setItem('auth_handle', handle);
      localStorage.setItem('auth_type', authType);
      setUser({ handle, token, authType });
      
      // Clean URL
      window.history.replaceState({}, document.title, '/');
      
      // Set a flag to indicate we just authenticated
      sessionStorage.setItem('justAuthenticated', 'true');
      sessionStorage.setItem('authHandle', handle);
      
      toast.success(`Welcome aboard, @${handle}! 🎉`);
      setLoading(false);
      return;
    }
    
    // Check for existing auth
    const existingToken = localStorage.getItem('auth_token');
    const existingHandle = localStorage.getItem('auth_handle');
    const existingAuthType = localStorage.getItem('auth_type') || 'secret_key';
    
    if (existingToken && existingHandle) {
      setUser({ handle: existingHandle, token: existingToken, authType: existingAuthType });
    }
    
    setLoading(false);
  }, []);

  // Login function
  const login = async (handle, secretKey) => {
    try {
      const response = await userAPI.authenticate(handle, secretKey);
      
      if (response.token) {
        localStorage.setItem('auth_token', response.token);
        localStorage.setItem('auth_handle', handle);
        localStorage.setItem('auth_type', 'secret_key');
        setUser({ handle, token: response.token, authType: 'secret_key' });
        toast.success('You\'re in! Let\'s get some questions 🚀');
        return true;
      }
    } catch (error) {
      toast.error(error.message || 'Hmm, that didn\'t work. Check your credentials?');
      return false;
    }
  };

  // Twitter login function
  const loginWithTwitter = () => {
    // In production (Railway), use relative URL. In development, use localhost.
    const isProduction = window.location.hostname !== 'localhost';
    const apiUrl = isProduction 
      ? '/api'  // Relative URL for production
      : (import.meta.env.VITE_API_URL || 'http://localhost:5001/api');
    
    window.location.href = `${apiUrl}/auth/twitter`;
  };

  // Logout function
  const logout = () => {
    localStorage.removeItem('auth_token');
    localStorage.removeItem('auth_handle');
    localStorage.removeItem('auth_type');
    setUser(null);
    toast.success('Signed out. See you soon! 👋');
  };

  // Check if user owns a specific handle
  const ownsHandle = (handle) => {
    if (!user?.handle || !handle) return false;
    return user.handle.toLowerCase() === handle.toLowerCase();
  };

  const value = {
    user,
    loading,
    login,
    loginWithTwitter,
    logout,
    ownsHandle,
    isAuthenticated: !!user,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// Custom hook to use auth context
export function useAuth() {
  const context = useContext(AuthContext);
  
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  
  return context;
} 


================================================
FILE: frontend/src/pages/HomePage.jsx
================================================
import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { userAPI } from '../services/api';
import { useAuth } from '../hooks/useAuth';
import Loading from '../components/Loading';

export default function HomePage() {
  const navigate = useNavigate();
  const { loginWithTwitter, user, isAuthenticated, loading: authLoading, logout } = useAuth();
  const [redirecting, setRedirecting] = React.useState(false);

  // Handle post-authentication redirect
  useEffect(() => {
    const justAuth = sessionStorage.getItem('justAuthenticated');
    const authHandle = sessionStorage.getItem('authHandle');
    
    if (justAuth === 'true' && authHandle && isAuthenticated) {
      setRedirecting(true);
      sessionStorage.removeItem('justAuthenticated');
      sessionStorage.removeItem('authHandle');
      navigate(`/inbox/${authHandle}`);
    }
  }, [isAuthenticated, navigate]);

  // Fetch user directory
  const { data: directory, isLoading: directoryLoading, error: directoryError } = useQuery({
    queryKey: ['userDirectory'],
    queryFn: () => userAPI.getDirectory(),
    staleTime: 5 * 60 * 1000, // 5 minutes
    retry: 1,
    onError: (error) => {
      console.error('Directory fetch error:', error);
    }
  });

  // Debug logging
  React.useEffect(() => {
    if (directory) {
      console.log('Directory data:', directory);
    }
    if (directoryError) {
      console.error('Directory error:', directoryError);
    }
  }, [directory, directoryError]);

  if (authLoading || redirecting) {
    return <Loading size="lg" className="mt-20" showMessage />;
  }

  return (
    <div className="min-h-[80vh] flex items-center justify-center p-4">
      <div className="max-w-md w-full">
        <div className="bg-white rounded-2xl shadow-xl p-8">
          <div className="text-center mb-8">
            <h1 className="text-4xl font-bold mb-2 text-gray-800">
              Ask Traders Anything
            </h1>
            <p className="text-gray-600 mb-2">
              Get honest insights • Stay anonymous • Learn together
            </p>
            {!isAuthenticated && (
              <p className="text-sm text-gray-500">
                Join in 5 seconds with Twitter – no forms, no hassle
              </p>
            )}
          </div>

          {isAuthenticated && user ? (
            // Logged in state
            <div className="space-y-4">
              {/* User info card */}
              <div className="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg p-4 border border-blue-100">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <div className="w-12 h-12 rounded-full bg-gradient-to-br from-blue-400 to-indigo-500 flex items-center justify-center text-white font-bold ring-2 ring-white">
                      {user.handle[0].toUpperCase()}
                    </div>
                    <div>
                      <p className="font-semibold text-gray-900">@{user.handle}</p>
                      <p className="text-sm text-gray-600">You're all set! 🚀</p>
                    </div>
                  </div>
                  <button
                    onClick={logout}
                    className="text-sm text-gray-500 hover:text-gray-700"
                    title="Sign out"
                  >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                    </svg>
                  </button>
                </div>
              </div>

              {/* Quick actions */}
              <div className="grid grid-cols-2 gap-3">
                <button
                  onClick={() => navigate(`/inbox/${user.handle}`)}
                  className="bg-blue-500 text-white py-3 px-4 rounded-lg font-semibold hover:bg-blue-600 transform hover:scale-105 transition duration-200 flex items-center justify-center gap-2"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4" />
                  </svg>
                  View Questions
                </button>
                <button
                  onClick={() => navigate(`/u/${user.handle}`)}
                  className="bg-gray-100 text-gray-700 py-3 px-4 rounded-lg font-semibold hover:bg-gray-200 transform hover:scale-105 transition duration-200 flex items-center justify-center gap-2"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                  </svg>
                  Your Page
                </button>
              </div>

              {/* Share link */}
              <div className="bg-gray-50 rounded-lg p-3">
                <p className="text-xs text-gray-600 mb-2 text-center font-medium">Share to receive questions:</p>
                <div className="flex items-center gap-2">
                  <code className="text-xs bg-white px-2 py-1 rounded border flex-1 truncate">
                    {window.location.origin}/u/{user.handle}
                  </code>
                  <button
                    onClick={(event) => {
                      navigator.clipboard.writeText(`${window.location.origin}/u/${user.handle}`);
                      // Small haptic feedback via transform
                      const btn = event.currentTarget;
                      btn.style.transform = 'scale(0.95)';
                      setTimeout(() => btn.style.transform = 'scale(1)', 100);
                    }}
                    className="text-blue-500 hover:text-blue-600 transition-transform"
                    title="Copy link"
                  >
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                  </button>
                </div>
              </div>
            </div>
          ) : (
            // Not logged in state
            <>
              <button
                onClick={loginWithTwitter}
                className="w-full bg-[#1DA1F2] text-white py-4 rounded-lg font-semibold hover:bg-[#1A8CD8] transform hover:scale-105 transition duration-200 flex items-center justify-center text-lg"
              >
                <svg className="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 24 24">
                  <path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/>
                </svg>
                Continue with Twitter
              </button>

              <div className="mt-8 p-4 bg-gray-50 rounded-lg">
                <p className="text-sm text-gray-600 text-center">
                  <strong>Why traders love TraderFM:</strong><br />
                  ✓ Ask tough questions anonymously<br />
                  ✓ Share knowledge without the noise<br />
                  ✓ Build your reputation through answers<br />
                  ✓ Connect with real traders instantly
                </p>
              </div>
            </>
          )}

          {/* User Directory */}
          <div className="mt-6">
            <p className="text-sm font-medium text-gray-700 mb-3 text-center">
              🔥 Trending Traders
            </p>
            {directoryLoading ? (
              <div className="flex justify-center">
                <Loading size="sm" />
              </div>
            ) : directory?.users?.length > 0 ? (
              <div className="grid grid-cols-1 gap-2 max-h-48 overflow-y-auto">
                {directory.users.slice(0, 10).map((user) => (
                  <button
                    key={user.handle}
                    onClick={() => navigate(`/u/${user.handle}`)}
                    className="flex items-center p-2 bg-gray-50 hover:bg-gray-100 rounded-lg transition text-left group"
                  >
                    {user.twitter_profile_image && (
                      <img
                        src={user.twitter_profile_image}
                        alt={user.handle}
                        className="w-8 h-8 rounded-full mr-3 group-hover:ring-2 group-hover:ring-blue-100 transition"
                      />
                    )}
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2">
                        <p className="text-sm font-medium text-gray-900 truncate">
                          @{user.handle}
                        </p>
                        {user.auth_type === 'twitter' && (
                          <svg className="w-3 h-3 text-blue-400" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/>
                          </svg>
                        )}
                      </div>
                      {user.twitter_name && (
                        <p className="text-xs text-gray-500 truncate">
                          {user.twitter_name}
                        </p>
                      )}
                      <p className="text-xs text-gray-400">
                        {user.answer_count} {user.answer_count === 1 ? 'answer' : 'answers'} shared
                      </p>
                    </div>
                  </button>
                ))}
              </div>
            ) : (
              <p className="text-sm text-gray-500 text-center">
                Be the pioneer! You'll be the first trader here 🎯
              </p>
            )}
          </div>
        </div>
      </div>
    </div>
  );
} 


================================================
FILE: frontend/src/pages/InboxPage.jsx
================================================
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import toast from 'react-hot-toast';
import { format } from 'date-fns';
import { questionsAPI, statsAPI } from '../services/api';
import { validateAnswer } from '../utils/validation';
import { useAuth } from '../hooks/useAuth.jsx';
import Loading from '../components/Loading';

export default function InboxPage() {
  const { handle } = useParams();
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const { ownsHandle, loading: authLoading, user } = useAuth();
  
  const [answeringId, setAnsweringId] = useState(null);
  const [answer, setAnswer] = useState('');
  const [errors, setErrors] = useState([]);

  // Check if already authenticated
  useEffect(() => {
    // Wait for auth to load before checking
    if (authLoading) return;
    
    // If user is not authenticated for this handle, redirect to home
    if (!ownsHandle(handle)) {
      console.log('Auth check failed:', { userHandle: user?.handle, pageHandle: handle });
      toast.error('This inbox belongs to someone else. Sign in to view yours!');
      navigate('/');
    }
  }, [handle, ownsHandle, navigate, authLoading, user]);

  // Fetch unanswered questions
  const { data: questions = [], isLoading: loadingQuestions } = useQuery({
    queryKey: ['questions', handle, 'unanswered'],
    queryFn: () => questionsAPI.getUnanswered(handle),
    enabled: ownsHandle(handle),
    refetchInterval: 5000, // Refresh every 5 seconds
  });

  // Fetch stats
  const { data: stats } = useQuery({
    queryKey: ['stats', handle],
    queryFn: () => statsAPI.getHandleStats(handle),
    enabled: ownsHandle(handle),
  });

  // Mutation for answering questions
  const answerMutation = useMutation({
    mutationFn: ({ questionId, answerText }) => 
      questionsAPI.answer(questionId, answerText),
    onSuccess: () => {
      queryClient.invalidateQueries(['questions', handle]);
      queryClient.invalidateQueries(['answers', handle]);
      queryClient.invalidateQueries(['stats', handle]);
      
      setAnswer('');
      setAnsweringId(null);
      toast.success('Answer published! Your insight is now live 🎯');
    },
    onError: (error) => {
      toast.error(error.message || 'Could not publish answer. Please try again.');
    },
  });

  // Mutation for deleting questions
  const deleteMutation = useMutation({
    mutationFn: (questionId) => questionsAPI.delete(questionId),
    onSuccess: () => {
      queryClient.invalidateQueries(['questions', handle]);
      queryClient.invalidateQueries(['stats', handle]);
      toast.success('Question removed ��️');
    },
  });



  const handleAnswer = (questionId) => {
    const validationErrors = validateAnswer(answer);
    if (validationErrors.length > 0) {
      setErrors(validationErrors);
      return;
    }

    answerMutation.mutate({ questionId, answerText: answer });
  };



  if (authLoading || loadingQuestions) {
    return <Loading size="lg" className="mt-20" />;
  }

  return (
    <div className="max-w-4xl mx-auto">
      {/* Header */}
      <div className="bg-white rounded-lg shadow-sm p-6 mb-6">
        <div className="flex items-center justify-between mb-4">
          <h1 className="text-2xl font-bold">Your Question Hub</h1>
          <button
            onClick={() => navigate(`/u/${handle}`)}
            className="text-blue-500 hover:text-blue-600 font-medium flex items-center gap-1"
          >
            View your public page
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
            </svg>
          </button>
        </div>

        {/* Stats */}
        {stats && (
          <div className="grid grid-cols-3 gap-4 mt-6">
            <div className="bg-gradient-to-br from-blue-50 to-indigo-50 rounded-lg p-4 text-center">
              <p className="text-2xl font-bold text-gray-800">{stats.totalQuestions}</p>
              <p className="text-sm text-gray-600">Questions received</p>
            </div>
            <div className="bg-gradient-to-br from-green-50 to-emerald-50 rounded-lg p-4 text-center">
              <p className="text-2xl font-bold text-gray-800">{stats.totalAnswers}</p>
              <p className="text-sm text-gray-600">Answers shared</p>
            </div>
            <div className="bg-gradient-to-br from-orange-50 to-amber-50 rounded-lg p-4 text-center">
              <p className="text-2xl font-bold text-gray-800">{questions.length}</p>
              <p className="text-sm text-gray-600">Awaiting answer</p>
            </div>
          </div>
        )}
      </div>

      {/* Share reminder */}
      <div className="bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-lg p-4 mb-6">
        <p className="text-sm text-blue-700">
          <strong>💡 Pro tip:</strong> More shares = more questions! Your unique link:{' '}
          <code className="bg-white px-2 py-1 rounded ml-1 font-mono text-xs">
            {window.location.origin}/u/{handle}
          </code>
          <button
            onClick={() => {
              navigator.clipboard.writeText(`${window.location.origin}/u/${handle}`);
              toast.success('Link copied! Share it everywhere 🚀');
            }}
            className="ml-2 text-blue-600 hover:text-blue-700 underline text-xs"
          >
            Copy
          </button>
        </p>
      </div>

      {/* Questions */}
      {questions.length === 0 ? (
        <div className="bg-white rounded-lg shadow-sm p-12 text-center">
          <p className="text-5xl mb-3 animate-bounce">📭</p>
          <p className="text-gray-700 font-semibold mb-2">Your inbox is empty</p>
          <p className="text-sm text-gray-500 mb-4">Questions will appear here when people ask them</p>
          <button
            onClick={() => {
              navigator.clipboard.writeText(`${window.location.origin}/u/${handle}`);
              toast.success('Link copied! Now share it 🎉');
            }}
            className="bg-blue-500 text-white px-4 py-2 rounded-lg text-sm hover:bg-blue-600 active-press"
          >
            Copy your link to share
          </button>
        </div>
      ) : (
        <div className="space-y-4">
          <h2 className="text-lg font-semibold text-gray-700">
            {questions.length === 1 
              ? '1 question waiting for your wisdom' 
              : `${questions.length} questions waiting for your wisdom`
            }
          </h2>

          {questions.map((q) => (
            <div key={q.id} className="bg-white rounded-lg shadow-sm p-6 transition hover:shadow-md">
              <div className="flex justify-between items-start mb-4">
                <p className="text-gray-800 flex-1 text-lg">{q.text}</p>
                <button
                  onClick={() => {
                    if (window.confirm('Delete this question? This cannot be undone.')) {
                      deleteMutation.mutate(q.id);
                    }
                  }}
                  disabled={deleteMutation.isLoading}
                  className="ml-4 text-gray-400 hover:text-red-500 transition"
                  title="Delete question"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                  </svg>
                </button>
              </div>

              <p className="text-xs text-gray-400 mb-4">
                Asked {format(new Date(q.createdAt), 'MMM d · h:mm a')}
              </p>

              {answeringId === q.id ? (
                <div className="space-y-3">
                  <textarea
                    value={answer}
                    onChange={(e) => {
                      setAnswer(e.target.value);
                      setErrors([]);
                    }}
                    placeholder="Share your insights... Be helpful, honest, and specific!"
                    className="w-full p-3 border-2 border-blue-400 rounded-lg resize-none focus:outline-none focus:border-blue-500"
                    rows={3}
                    autoFocus
                    disabled={answerMutation.isLoading}
                  />
                  
                  {errors.length > 0 && (
                    <div className="space-y-1">
                      {errors.map((error, idx) => (
                        <p key={idx} className="text-red-500 text-sm">{error}</p>
                      ))}
                    </div>
                  )}

                  <div className="flex gap-2">
                    <button
                      onClick={() => handleAnswer(q.id)}
                      disabled={answerMutation.isLoading || !answer.trim()}
                      className="px-4 py-2 bg-blue-500 text-white rounded-lg font-semibold hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed active-press"
                    >
                      {answerMutation.isLoading ? 'Publishing...' : 'Publish Answer'}
                    </button>
                    <button
                      onClick={() => {
                        setAnsweringId(null);
                        setAnswer('');
                        setErrors([]);
                      }}
                      disabled={answerMutation.isLoading}
                      className="px-4 py-2 text-gray-600 hover:text-gray-800 active-press"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              ) : (
                <button
                  onClick={() => {
                    setAnsweringId(q.id);
                    // Auto-focus will happen due to autoFocus prop on textarea
                  }}
                  className="bg-blue-100 text-blue-700 px-4 py-2 rounded-lg hover:bg-blue-200 transition active-press font-medium"
                >
                  Write Answer →
                </button>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
} 


================================================
FILE: frontend/src/pages/ProfilePage.jsx
================================================
import React, { useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useQuery, useMutation } from '@tanstack/react-query';
import toast from 'react-hot-toast';
import { format } from 'date-fns';
import { questionsAPI, answersAPI, userAPI } from '../services/api';
import { validateQuestion } from '../utils/validation';
import { containsProfanity, getProfanityMessage } from '../utils/profanity';
import { useAuth } from '../hooks/useAuth.jsx';
import Loading from '../components/Loading';

export default function ProfilePage() {
  const { handle } = useParams();
  const navigate = useNavigate();
  const { ownsHandle } = useAuth();
  const [question, setQuestion] = useState('');
  const [errors, setErrors] = useState([]);

  // Check if handle exists
  const { data: profileData, isLoading: checkingHandle, error: profileError } = useQuery({
    queryKey: ['handle', handle],
    queryFn: () => userAPI.checkHandle(handle),
    retry: 1,
    onError: (error) => {
      console.error('Profile check error:', error);
      // Only navigate away for 404 errors
      if (error.status === 404 || error.message === 'Handle not found') {
        toast.error(`Hmm, @${handle} hasn't joined yet. Maybe invite them? 🤔`);
        navigate('/');
      } else {
        toast.error('Having trouble loading this page. Try refreshing?');
      }
    },
  });

  // Fetch answers
  const { data: answersData, isLoading: loadingAnswers } = useQuery({
    queryKey: ['answers', handle],
    queryFn: () => answersAPI.getByHandle(handle),
    enabled: !!profileData?.exists,
    refetchInterval: 10000, // Refresh every 10 seconds
  });

  // Mutation for asking questions
  const askQuestionMutation = useMutation({
    mutationFn: (text) => questionsAPI.ask(handle, text),
    onSuccess: () => {
      setQuestion('');
      toast.success('Question sent! The trader will see it soon.');
    },
    onError: (error) => {
      if (error.message?.includes('rate limit')) {
        toast.error('Too many questions! Please wait a bit.');
      } else {
        toast.error(error.message || 'Failed to send question');
      }
    },
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Validate question
    const validationErrors = validateQuestion(question);
    if (validationErrors.length > 0) {
      setErrors(validationErrors);
      return;
    }

    // Check profanity
    if (containsProfanity(question)) {
      setErrors([getProfanityMessage()]);
      return;
    }

    askQuestionMutation.mutate(question);
  };

  if (checkingHandle || loadingAnswers) {
    return <Loading size="lg" className="mt-20" />;
  }

  const answers = answersData?.answers || [];
  const totalAnswers = answersData?.total || 0;
  const isOwner = ownsHandle(handle);
  const shareUrl = `${window.location.origin}/u/${handle}`;

  return (
    <div className="max-w-2xl mx-auto">

      {/* Header */}
      <div className="bg-white rounded-lg shadow-sm p-6 mb-6">
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-3">
            {profileData?.twitter_profile_image && (
              <img
                src={profileData.twitter_profile_image}
                alt={handle}
                className="w-12 h-12 rounded-full"
              />
            )}
            <div>
              <h1 className="text-2xl font-bold flex items-center gap-2">
                @{handle}
                {profileData?.auth_type === 'twitter' && (
                  <svg className="w-5 h-5 text-blue-400" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/>
                  </svg>
                )}
              </h1>
              {profileData?.twitter_name && (
                <p className="text-sm text-gray-500">{profileData.twitter_name}</p>
              )}
            </div>
          </div>
          {isOwner && (
            <button
              onClick={() => navigate(`/inbox/${handle}`)}
              className="text-blue-500 hover:text-blue-600 font-medium flex items-center gap-1"
            >
              View inbox
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
              </svg>
            </button>
          )}
        </div>
        
        <p className="text-gray-600 mb-4">
          {isOwner 
            ? "This is your public page. Share it to receive anonymous questions!"
            : `Got a burning question? Ask @${handle} anonymously – they can't see who you are.`
          }
        </p>

        {/* Ask question form - only show if not owner */}
        {!isOwner && (
          <form onSubmit={handleSubmit} className="space-y-4">
            <div>
              <div className="relative">
                <textarea
                  value={question}
                  onChange={(e) => {
                    setQuestion(e.target.value);
                    setErrors([]);
                  }}
                  placeholder="Ask your question here... Be specific to get the best answer!"
                  className="w-full p-4 border-2 border-gray-200 rounded-lg resize-none focus:outline-none focus:border-blue-400 transition"
                  rows={3}
                  maxLength={280}
                  disabled={askQuestionMutation.isLoading}
                />
                <div className="absolute bottom-2 right-2 text-sm text-gray-400">
                  {question.length}/280
                </div>
              </div>
              
              {errors.length > 0 && (
                <div className="mt-2 space-y-1">
                  {errors.map((error, idx) => (
                    <p key={idx} className="text-red-500 text-sm">{error}</p>
                  ))}
                </div>
              )}
            </div>

            <button
              type="submit"
              disabled={askQuestionMutation.isLoading || !question.trim()}
              className="w-full bg-blue-500 text-white py-3 rounded-lg font-semibold hover:bg-blue-600 transform hover:scale-105 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none active-press"
            >
              {askQuestionMutation.isLoading ? 'Sending...' : 'Ask Your Question →'}
            </button>
          </form>
        )}
      </div>

      {/* Answers section */}
      <div className="bg-white rounded-lg shadow-sm p-6">
        <h2 className="text-xl font-bold mb-6">
          {totalAnswers === 0 
            ? "Questions & Answers" 
            : `${totalAnswers} Public ${totalAnswers === 1 ? 'Answer' : 'Answers'}`
          }
        </h2>

        {answers.length === 0 ? (
          <div className="text-center py-12">
            <div className="text-4xl mb-3">💭</div>
            <p className="text-gray-500 mb-2">
              {isOwner ? "No questions answered yet" : "No answers yet"}
            </p>
            <p className="text-sm text-gray-400">
              {isOwner 
                ? "Share your page link to start receiving questions!" 
                : "Be brave – ask the first question!"
              }
            </p>
          </div>
        ) : (
          <div className="space-y-6">
            {answers.map((answer, index) => (
              <div 
                key={answer.id} 
                className="border-l-4 border-blue-100 pl-4 py-2 hover-lift"
                style={{ animationDelay: `${index * 50}ms` }}
              >
                <p className="text-gray-600 mb-2">
                  <span className="font-semibold text-gray-400">Anonymous asked:</span> {answer.questionText}
                </p>
                <p className="text-gray-900">
                  <span className="font-semibold text-blue-600">@{handle}:</span> {answer.answerText}
                </p>
                <p className="text-xs text-gray-400 mt-2">
                  {format(new Date(answer.createdAt), 'MMM d, yyyy · h:mm a')}
                </p>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Share section */}
      <div className="mt-6 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg p-4 border border-blue-100">
        <p className="text-sm font-medium text-gray-700 text-center mb-2">
          {isOwner ? "📤 Your unique link" : "🔗 Share this trader's page"}
        </p>
        <div className="flex items-center justify-center gap-2">
          <code className="bg-white px-3 py-1 rounded border text-sm font-mono">{shareUrl}</code>
          <button
            onClick={(event) => {
              navigator.clipboard.writeText(shareUrl);
              toast.success('Copied to clipboard! 🎉');
              
              // Visual feedback
              const btn = event.currentTarget;
              btn.classList.add('animate-pulse');
              setTimeout(() => btn.classList.remove('animate-pulse'), 1000);
            }}
            className="text-blue-500 hover:text-blue-600 active-press"
            title="Copy link"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
            </svg>
          </button>
        </div>
        {isOwner && (
          <p className="text-xs text-gray-500 text-center mt-2">
            Post this on Twitter, share in group chats, or add to your bio
          </p>
        )}
      </div>

    </div>
  );
} 


================================================
FILE: frontend/src/services/api.js
================================================
import axios from 'axios';

// API Base URL - can be overridden by environment variable
const API_BASE = import.meta.env.VITE_API_URL || '/api';

// Create axios instance with default config
const api = axios.create({
  baseURL: API_BASE,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add auth token to requests if available
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('auth_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Handle API responses
api.interceptors.response.use(
  (response) => response.data,
  (error) => {
    console.error('API Error:', {
      status: error.response?.status,
      data: error.response?.data,
      url: error.config?.url,
      method: error.config?.method
    });
    
    if (error.response?.status === 401) {
      // Clear auth and redirect to home
      localStorage.removeItem('auth_token');
      window.location.href = '/';
    }
    
    // Create a proper error object with all details
    const errorObj = {
      message: error.response?.data?.message || error.message || 'Network error',
      status: error.response?.status,
      data: error.response?.data,
      ...error.response?.data // Spread any additional error fields
    };
    
    return Promise.reject(errorObj);
  }
);

// User/Handle API
export const userAPI = {
  checkHandle: (handle) => api.get(`/users/check/${handle}`),
  createHandle: (handle) => api.post('/users/create', { handle }),
  authenticate: (handle, secretKey) => api.post('/users/auth', { handle, secretKey }),
  getDirectory: () => api.get('/users/directory'),
};

// Questions API
export const questionsAPI = {
  ask: (handle, text) => api.post(`/questions/${handle}`, { text }),
  getUnanswered: (handle) => api.get(`/questions/${handle}/unanswered`),
  answer: (questionId, answerText) => api.post(`/questions/${questionId}/answer`, { answerText }),
  delete: (questionId) => api.delete(`/questions/${questionId}`),
};

// Answers API
export const answersAPI = {
  getByHandle: (handle, page = 1, limit = 20) => 
    api.get(`/answers/${handle}`, { params: { page, limit } }),
  delete: (answerId) => api.delete(`/answers/${answerId}`),
};

// Stats API
export const statsAPI = {
  getHandleStats: (handle) => api.get(`/stats/${handle}`),
};

export default api; 


================================================
FILE: frontend/src/utils/profanity.js
================================================
// Comprehensive profanity filter
const profanityPatterns = [
  // Common profanity (with character variations)
  /\bf+[u\*]+c+k+/i,
  /\bs+h+[i\*]+t+/i,
  /\ba+s+s+h+o+l+e+/i,
  /\bb+[i\*]+t+c+h+/i,
  /\bd+a+m+n+/i,
  /\bh+e+l+l+/i,
  /\bc+r+a+p+/i,
  /\bp+[i\*]+s+s+/i,
  
  // Slurs and offensive terms
  /\bn+[i\*]+g+g+[ae]+r*/i,
  /\bf+a+g+g*[oi]+t*/i,
  /\br+e+t+a+r+d+/i,
  
  // Sexual terms
  /\bd+[i\*]+c+k+/i,
  /\bc+o+c+k+/i,
  /\bp+u+s+s+y+/i,
  /\bc+u+n+t+/i,
  
  // Additional variations
  /\bw+t+f+/i,
  /\bs+t+f+u+/i,
];

// Check if text contains profanity
export const containsProfanity = (text) => {
  if (!text) return false;
  
  // Check against patterns
  const hasProfanity = profanityPatterns.some(pattern => pattern.test(text));
  
  // Also check for attempts to bypass filter with special characters
  const normalizedText = text
    .replace(/[@#$%&*]/g, '') // Remove special chars
    .replace(/[0-9]/g, (match) => {
      // Replace numbers that look like letters
      const replacements = { '0': 'o', '1': 'i', '3': 'e', '4': 'a', '5': 's', '7': 't' };
      return replacements[match] || match;
    });
  
  return hasProfanity || profanityPatterns.some(pattern => pattern.test(normalizedText));
};

// Clean text by replacing profanity with asterisks
export const cleanProfanity = (text) => {
  if (!text) return text;
  
  let cleaned = text;
  profanityPatterns.forEach(pattern => {
    cleaned = cleaned.replace(pattern, (match) => '*'.repeat(match.length));
  });
  
  return cleaned;
};

// Get a user-friendly error message
export const getProfanityMessage = () => {
  const messages = [
    "Please keep it respectful!",
    "Let's keep things civil.",
    "That language isn't allowed here.",
    "Please rephrase without profanity.",
    "Keep it clean, please!"
  ];
  
  return messages[Math.floor(Math.random() * messages.length)];
}; 


================================================
FILE: frontend/src/utils/validation.js
================================================
// Handle validation
export const validateHandle = (handle) => {
  const errors = [];
  
  if (!handle || !handle.trim()) {
    errors.push('Choose a handle to get started');
    return errors;
  }
  
  if (handle.length < 3) {
    errors.push('Handles need at least 3 characters');
  }
  
  if (handle.length > 20) {
    errors.push('Keep it under 20 characters');
  }
  
  if (!/^[a-z0-9]+$/.test(handle)) {
    errors.push('Use only lowercase letters and numbers');
  }
  
  if (/^\d+$/.test(handle)) {
    errors.push('Mix in some letters with those numbers');
  }
  
  // Reserved handles
  const reserved = ['api', 'admin', 'inbox', 'login', 'signup', 'about', 'help', 'support'];
  if (reserved.includes(handle.toLowerCase())) {
    errors.push('That handle is reserved – try another');
  }
  
  return errors;
};

// Question validation
export const validateQuestion = (text) => {
  const errors = [];
  
  if (!text || !text.trim()) {
    errors.push('Type your question first');
    return errors;
  }
  
  if (text.length < 5) {
    errors.push('Add a bit more detail (5+ characters)');
  }
  
  if (text.length > 280) {
    errors.push('Keep it under 280 characters');
  }
  
  // Check if it's just repeated characters
  if (/^(.)\1+$/.test(text.trim())) {
    errors.push('Ask a real question – we know you\'re curious!');
  }
  
  // Check if it's just spaces and punctuation
  if (!/[a-zA-Z0-9]/.test(text)) {
    errors.push('Add some actual words to your question');
  }
  
  return errors;
};

// Answer validation
export const validateAnswer = (text) => {
  const errors = [];
  
  if (!text || !text.trim()) {
    errors.push('Share your thoughts – even a short answer helps');
    return errors;
  }
  
  if (text.length > 1000) {
    errors.push('Great insights! But keep it under 1000 characters');
  }
  
  return errors;
};

// Format handle for display
export const formatHandle = (handle) => {
  if (!handle) return '';
  return `@${handle}`;
};

// Format URL for sharing
export const getShareUrl = (handle) => {
  return `${window.location.origin}/u/${handle}`;
}; 

